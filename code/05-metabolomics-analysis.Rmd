---
title: "05-metabolomics-analysis"
author: "Yaamini Venkataraman"
date: '2023-12-18'
output: html_document
---

In this script, I will analyze metabolomics data from the West Coast Metabolomics Center (UC Davis). I will conduct an initial assessment of the data (PLS-DA), understand important metabolites and pathways (VIP analysis and WGCNA), and prepare for additional network analysis through MetaboAnalyst. This workflow and script is modified from [Huffmyer et al. (2023)](https://www.biorxiv.org/content/10.1101/2023.03.20.533475v2.full) and [Trigg et al. (2019)](http://dx.doi.org/10.1038/s41598-019-46947-6).

# Set up R Markdown document

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath("../output/05-metabolomics-analysis/")) #Set root directory
```

```{r}
getwd()
```

# Install packages

```{r packages, warning = FALSE, message = FALSE}
# if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse') 
# if ("vegan" %in% rownames(installed.packages()) == 'FALSE') install.packages('vegan') 
# if ("factoextra" %in% rownames(installed.packages()) == 'FALSE') install.packages('factoextra') 
# if ("ggfortify" %in% rownames(installed.packages()) == 'FALSE') install.packages('ggfortify') 
# if ("naniar" %in% rownames(installed.packages()) == 'FALSE') install.packages('naniar') 
# if ("cowplot" %in% rownames(installed.packages()) == 'FALSE') install.packages('cowplot') 
# if (!requireNamespace("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# if ("mixOmics" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("mixOmics") 
# if ("RVAideMemoire" %in% rownames(installed.packages()) == 'FALSE') install.packages('RVAideMemoire') 
# if ("VennDiagram" %in% rownames(installed.packages()) == 'FALSE') install.packages('VennDiagram') 
# if ("broom" %in% rownames(installed.packages()) == 'FALSE') install.packages('broom') 
# if ("RColorBrewer" %in% rownames(installed.packages()) == 'FALSE') install.packages('RColorBrewer') 
# if ("pheatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('pheatmap') 
# if ("genefilter" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("genefilter") 
# if ("WGCNA" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('WGCNA')
if ("dendsort" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('dendsort') 
if ("ComplexHeatmap" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ComplexHeatmap') 

require(tidyverse)
require(vegan)
# require(factoextra)
# require(ggfortify)
# require(naniar)
# require(cowplot)
require(mixOmics)
require(RVAideMemoire)
# require(VennDiagram)
require(broom)
require(RColorBrewer)
require(pheatmap)
require(genefilter)
require(WGCNA)
require(dendsort)
require(ComplexHeatmap)
```

```{r}
source("../../code/biostats.R") #Source multivariate analysis functions
```

```{r}
sessionInfo()
```

# Import data

```{r}
rawMetabolomicsData <- read.csv("../../data/raw_metabolomics_data.csv", header = TRUE) %>% 
  dplyr::rename_with(~stringr::str_replace_all(., "X", "")) #Import data. Remove the "X" prefix for crab IDs
head(rawMetabolomicsData) #Confirm import
```

```{r}
metabolomicsMetadata <- read.csv("../../data/metabolomics_metadata.csv", header = FALSE, strip.white = TRUE) %>% 
  dplyr::rename_with(~stringr::str_replace_all(., "V", "")) %>%
  t(.) %>% as.data.frame(.) %>% 
  purrr::set_names(as.character(dplyr::slice(., 1))) %>%
  dplyr::slice(., -1) %>% 
  mutate(., unite(., "treatment_day", treatment:day, sep = "_")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = "_  3", replacement = "_3")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = "_ 22", replacement = "_22")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = " 13_", replacement = "13_")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = " 30_", replacement = "30_")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = "  5_", replacement = "5_")) #Import metadata. Do not include any header information. Remove "V" from column names. Transform so crab.ID, treatment, and day are all columns. Set the first row in the dataframe as column names, then remove that row.
tail(metabolomicsMetadata) #Confirm import
```

# Format data

Before analyzing the data, I will transform the data and match with treatment metadata. The West Coast Metabolomics Center has already normalized data using the average mTIC (sum of all peak heights for *identified* metabolites) of the samples. 

```{r}
transMetabData <- rawMetabolomicsData %>%
  dplyr::select(., -c(2:8)) %>%
  column_to_rownames(., var = "BinBase.name") %>%
  t(.) %>% as.data.frame(.) %>%
  rownames_to_column(., var = "crab.ID") %>% 
  left_join(metabolomicsMetadata, ., by = "crab.ID") #Remove columns with MS information, convert BinBase.name to rownames, and transform dataframe. Convert rownames to crab.ID column
head(transMetabData) #Confirm changes
```

# Initial data investigation with PCA

```{bash}
mkdir PCA
mkdir PCA/figures
```

```{r}
scaled.pca <- prcomp(transMetabData[c(5:601)], scale = TRUE, center = TRUE) #Use prcomp to perform a centered and scaled PCA calculation
summary(scaled.pca) #Standard deviations for each PC
```

```{r PCA interpretation}
pca.eigenval(scaled.pca) #Eigenvalues greater than the broken-stick expectation are considered to explain a statistically significance proportion of the variance in the original dataset. PC3 and PC4 eigenvalue > BSV
ordiMonteRandTest <- ordi.monte(transMetabData[c(5:601)], ord = "pca", dim = 6, plot = FALSE) #Conduct monte carlo randomization test using 1000 random permutations of the input data.
ordiMonteRandTest

#Will move forward with PC1-2
```

## Plot PCA

```{r}
plotColors <- c(brewer.pal(9, "Reds")[7],
                brewer.pal(9, "Greys")[7],
                brewer.pal(9, "Blues")[7]) #Create color scheme
```

### All metabolites

```{r}
pcaPlot1 <- autoplot(scaled.pca, data = transMetabData, x = 1, y = 2,
                     size = 3, alpha = 0.8, colour = "treatment", shape = "treatment", 
                     frame = TRUE, frame.colour = "treatment", loadings = FALSE) +
  scale_color_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                     name = "Temperature (ºC)") +
  scale_fill_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                    name = "Temperature (ºC)") +
  scale_shape_manual(values = c(15, 19, 17),
                     name = "Temperature (ºC)") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Use autoplot to plot the prcomp object. Color points and confidence ellipses by treatment, and have different shapes for each treatment Do not include loadings. Manually define color, fill, and shapes.
pcaPlot1
ggsave("PCA/figures/all-data-PCA-treatment.pdf", height = 8.5, width = 11)
```

```{r}
pcaPlot2 <- autoplot(scaled.pca, data = transMetabData, x = 1, y = 2,
                     size = 5, alpha = 0.8, colour = "day", shape = "day",
                     frame = TRUE, frame.colour = "day", loadings = FALSE) +
  scale_color_manual(values = c("black", "purple"),
                     name = "Day") +
  scale_fill_manual(values = c("black", "purple"),
                    name = "Day") +
  scale_shape_manual(values = c(20, 18),
                     name = "Day") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Same as above but color by day and not treatment
pcaPlot2
ggsave("PCA/figures/all-data-PCA-day.pdf", height = 8.5, width = 11)
```

```{r}
pcaPlot3 <- autoplot(scaled.pca, data = transMetabData, x = 1, y = 2,
                     size = 4, alpha = 0.8, colour = "treatment", shape = "day", 
                     frame = TRUE, frame.colour = "treatment", loadings = FALSE) +
  scale_color_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                     name = "Temperature (ºC)") +
  scale_fill_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                    name = "Temperature (ºC)") +
  scale_shape_manual(values = c(20, 18),
                     name = "Day") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Use autoplot to plot the prcomp object. Color points and confidence ellipses by treatment, and have different shapes for each day. Do not include loadings. Manually define color, fill, and shapes.
pcaPlot3
ggsave("PCA/figures/all-data-PCA-day-treatment.pdf", height = 8.5, width = 11)
```

Overall, it seems like metabolite profiles are segregating by treatment, with the 30ºC profiles more segregated from the 5ºC and 13ºC profiles. It also seems like metabolite profiles have higher spread over time, potentially due to the impact of prolonged temperature exposure on physiology.

### Identified metabolites

I'm going to make a very similar PCA to the one above, but only using metabolites identified by the sequencer.

```{r}
scaled.pca.id <- prcomp(transMetabData[c(4:155)], scale = TRUE, center = TRUE) #Use prcomp to perform a centered and scaled PCA calculation
summary(scaled.pca.id) #Standard deviations for each PC
```

```{r}
pcaPlot4 <- autoplot(scaled.pca.id, data = transMetabData, x = 1, y = 2,
                     size = 4, alpha = 0.8, colour = "treatment", shape = "day", 
                     frame = TRUE, frame.colour = "treatment", loadings = FALSE) +
  scale_color_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                     name = "Temperature (ºC)") +
  scale_fill_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                    name = "Temperature (ºC)") +
  scale_shape_manual(values = c(20, 18),
                     name = "Day") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Use autoplot to plot the prcomp object. Color points and confidence ellipses by treatment, and have different shapes for each day. Do not include loadings. Manually define color, fill, and shapes.
pcaPlot4
ggsave("PCA/figures/known-metabolites-PCA-day-treatment.pdf", height = 8.5, width = 11)
```

## Conduct PERMANOVA

I'll use a global permutational multivariate analysis of variance (PERMANOVA) to determine if treatment and day had a significant influence on metabolite profiles. The significant effects from the PCA will be used in the downstream PLS-DA to interrogate trends.

### All metabolites

```{r}
permanova.metab <- adonis2(scale(transMetabData[c(5:601)]) ~ treatment*day, data = transMetabData, method = 'eu') #Conduct global PERMANOVA to assess significance of trends in PCA. Scale metabolomics data and assess influence of treatment, day, and treatment x day on metabolite profiles
permanova.metab #Significant influence of all factors
```

```{r}
broom::tidy(permanova.metab) %>%
  write.csv(., "PCA/all-data-PERMANOVA-results.csv", quote = FALSE) #Save PERMANOVA output
```

### Identified metabolites

I'm going to repeat the same analysis, but only look at trends for metabolites identified by the West Coast Metabolomics Center.

```{r}
permanova.metabid <- adonis2(scale(transMetabData[c(5:156)]) ~ treatment*day, data = transMetabData, method = 'eu') #Conduct global PERMANOVA to assess significance of trends in PCA. Scale metabolomics data and assess influence of treatment, day, and treatment x day on metabolite profiles
permanova.metabid #Significant influence of all factors
```

```{r}
broom::tidy(permanova.metab) %>%
  write.csv(., "PCA/known-metabolites-PERMANOVA-results.csv", quote = FALSE) #Save PERMANOVA output
```

The fact that all three explanatory variables are significant means that the inclusion of unidentified metabolites doesn't drastically influence the results.

# PLSDA for all metabolites

The next step is for me to conduct a PLS-DA analysis using the `mixOmics` package. This is a more robust way to analyze differences between treatments and is common in many metabolomics studies. Since both temperature and day were significant in the PCA, I'll use both of those factors in the PLSDA.

```{bash}
mkdir PLSDA
mkdir PLSDA/figures
```


## Temperature only

I'm still going to run the PLS-DA with temperature only because I suspect the plot will look cleaner this way.

```{r}
X <- log(transMetabData[c(5:601)]) #Assign only metabolite data to the X dataframe after log transformation.
Y <- as.factor(transMetabData$treatment) #Assign treatment data to the Y dataframe
```

```{r}
treatment.plsda <- plsda(X,Y, ncomp = 2) #ncomp = # treatments - 1
plotIndiv(treatment.plsda)
```

```{r}
#pdf("PLSDA/figures/all-data-PLSDA-treatment.pdf", height = 8.5, width = 11)
plotIndiv(treatment.plsda, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = rev(plotColors), pch = c(15, 17, 19), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC)", 
          title = "PLS-DA by Temperature", X.label = "Component 1: 14% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 6% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
pdf("PLSDA/figures/all-data-cimPlot-treatment.pdf", height = 8.5, width = 11)
cim(treatment.plsda, mapping = "Y", row.names = transMetabData$treatment, xlab = "Metabolites", ylab = "Temperature (ºC)", margins = c(8, 5), row.cex = 0.5) #Create CIM plot with metabolites on the x-axis and treatment on the y-axis. 
dev.off()
```

### Extract VIP

The VIP are the metabolites most important for distinguishing between treatments.

```{r}
treatmentVIP <- as.data.frame(PLSDA.VIP(treatment.plsda)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") #Extract VIP information and save as a dataframe. Convert metabolite rownames to a column. 
head(treatmentVIP) #Confirm changes
```

```{r}
write.csv(treatmentVIP, "PLSDA/all-data-VIP-treatment.csv", quote = FALSE, row.names = FALSE) #Save VIP scores
```

```{r}
treatmentVIP %>%
  filter(VIP >= 1) %>%
  nrow(.) #236 metabolites have VIP > 1
236/596 * 100 #39.6% metabolites VIP > 1
```

```{r}
treatmentVIP %>%
  filter(VIP >= 1) %>%
  arrange(VIP) %>%
  ggplot(aes(x = VIP, y = reorder(metabolite, VIP, sum))) +
  geom_point() +
  xlab("VIP Score") + ylab("Metabolite") +
  theme_classic() + theme(axis.text.y = element_text(size = 5)) #Using only metabolites with VIP > 1, arrange by metabolite name and reorder by cumulative VIP score. Plot points and change x and y axis labels.
ggsave("PLSDA/figures/all-data-VIP.pdf", height = 8.5, width = 11)
```
## Temperature x day

```{r}
X <- log(transMetabData[c(5:601)]) #Assign only metabolite data to the X dataframe after log transformation
Y <- as.factor(transMetabData$treatment_day) #Assign treatment data to the Y dataframe
```

```{r}
treatmentday.plsda <- plsda(X,Y, ncomp = 5) #ncomp = # treatments - 1
plotIndiv(treatmentday.plsda)
```
```{r}
#pdf("PLSDA/figures/all-data-PLSDA-day-treatment-comp12.pdf", height = 8.5, width = 11)
plotIndiv(treatmentday.plsda, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "PLS-DA by Temperature and Day", X.label = "Component 1: 14% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 6% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
#pdf("PLSDA/figures/all-data-PLSDA-day-treatment-comp13.pdf", height = 8.5, width = 11)
plotIndiv(treatmentday.plsda, comp = c(1,3), ind.names = FALSE,
          cex = 3, col = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "PLS-DA by Temperature and Day", X.label = "Component 1: 14% Explained Variance", size.xlabel = 15, Y.label = "Component 3: 11% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
pdf("PLSDA/figures/all-data-cimPlot-day-treatment.pdf", height = 8.5, width = 11)
cim(treatment.plsda, mapping = "Y", row.names = transMetabData$treatment_day, xlab = "Metabolites", ylab = "Temperature (ºC) x Day", margins = c(8, 5), row.cex = 0.5) #Create CIM plot with metabolites on the x-axis and treatment x day on the y-axis. 
dev.off()
```

### Extract VIP

```{r}
treatmentdayVIP <- as.data.frame(PLSDA.VIP(treatmentday.plsda)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") #Extract VIP information and save as a dataframe. Convert metabolite rownames to a column.
head(treatmentdayVIP) #Confirm changes
```

```{r}
write.csv(treatmentdayVIP, "PLSDA/all-data-VIP-day-treatment.csv", quote = FALSE, row.names = FALSE) #Save VIP scores
```

```{r}
treatmentdayVIP %>%
  filter(VIP >= 1) %>%
  nrow(.) #251 metabolites have VIP > 1
251/596 * 100 #42.1% metabolites VIP > 1
```

```{r}
treatmentdayVIP %>%
  filter(VIP >= 1) %>%
  arrange(VIP) %>%
  ggplot(aes(x = VIP, y = reorder(metabolite, VIP, sum))) +
  geom_point() +
  xlab("VIP Score") + ylab("Metabolite") +
  theme_classic() + theme(axis.text.y = element_text(size = 5)) #Using only metabolites with VIP > 1, arrange by metabolite name and reorder by cumulative VIP score. Plot points and change x and y axis labels.
ggsave("PLSDA/figures/all-data-VIP-day-treatment.pdf", height = 8.5, width = 11)
```

# PLSDA for known features

While I can use the PLSDA with all features to discuss larger patterns and maybe glean insight into functions of unknown metabolites, running the model with only known features will allow me to more confidently assess differences in metabolic pathways due to temperature and time. I will run this PLSDA for both temperature and day.

```{r}
X <- log(transMetabData[c(5:156)]) #Assign known metabolite data to the X dataframe after log transformation
Y <- as.factor(transMetabData$treatment_day) #Assign treatment data to the Y dataframe
```

```{r}
treatmentday.known.plsda <- plsda(X,Y, ncomp = 5) #ncomp = # treatments - 1
plotIndiv(treatmentday.known.plsda)
```

```{r}
#pdf("PLSDA/figures/known-metabolites-PLSDA-day-treatment-comp12.pdf", height = 8.5, width = 11)
plotIndiv(treatmentday.known.plsda, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "PLS-DA by Temperature and Day", X.label = "Component 1: 12% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 12% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
#pdf("PLSDA/figures/known-metabolites-PLSDA-day-treatment-comp13.pdf", height = 8.5, width = 11)
plotIndiv(treatmentday.known.plsda, comp = c(1,3), ind.names = FALSE,
          cex = 3, col = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "PLS-DA by Temperature and Day", X.label = "Component 1: 12% Explained Variance", size.xlabel = 15, Y.label = "Component 3: 8% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
pdf("PLSDA/figures/known-metabolites-cimPlot-day-treatment.pdf", height = 8.5, width = 11)
cim(treatmentday.known.plsda, mapping = "Y", row.names = transMetabData$treatment_day, xlab = "Metabolites", ylab = "Temperature (ºC) x Day", margins = c(8, 5), row.cex = 0.5) #Create CIM plot with metabolites on the x-axis and treatment x day on the y-axis. 
dev.off()
```

### Extract VIP

```{r}
treatmentday.known.VIP <- as.data.frame(PLSDA.VIP(treatmentday.known.plsda)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") #Extract VIP information and save as a dataframe. Convert metabolite rownames to a column.
head(treatmentdayVIP) #Confirm changes
```

```{r}
write.csv(treatmentday.known.VIP, "PLSDA/known-metabolites-VIP-day-treatment.csv", quote = FALSE, row.names = FALSE) #Save VIP scores
```

```{r}
treatmentday.known.VIP %>%
  filter(VIP >= 1) %>%
  nrow(.) #73 metabolites have VIP > 1
73/151 * 100 #48.3% metabolites VIP > 1
```

```{r}
treatmentday.known.VIP %>%
  filter(VIP >= 1) %>%
  arrange(VIP) %>%
  ggplot(aes(x = VIP, y = reorder(metabolite, VIP, sum))) +
  geom_point() +
  xlab("VIP Score") + ylab("Metabolite") +
  theme_classic() + theme(axis.text.y = element_text(size = 8)) #Using only metabolites with VIP > 1, arrange by metabolite name and reorder by cumulative VIP score. Plot points and change x and y axis labels.
ggsave("PLSDA/figures/known-metabolites-VIP-day-treatment.pdf", height = 8.5, width = 11)
```

## Pairwise tests for VIP metabolites

We now know which metabolites are most important for separating days and treatments. However, we do not know specifically which VIP distinguish between which treatment x day contrasts. I will use pairwise t-tests to identify which VIP are important for which contrasts. 

### Treatment differences at day 3

#### 13_3 vs. 30_3

```{r}
list <- c("13_3", "30_3") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13v30_day3 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13v30_day3 <- as.data.frame(PLSDA.VIP(known.plsda_13v30_day3)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
```

```{r}
clean_13v30_day3 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13v30_day3 <- cbind(clean_13v30_day3[, 1:4], 
                               log(clean_13v30_day3[, names(clean_13v30_day3) %in% VIP_13v30_day3$metabolite])) %>%
  pivot_longer(., cols = 5:63, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13v30_day3 #Confirm changes
```

```{r}
t.test_13v30_day3 <-do(VIP_select_13v30_day3, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                          alternative = "two.sided",
                                                          mu = 0,
                                                          paired = FALSE,
                                                          var.equal = FALSE,
                                                          conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13v30_day3$p.adj <- p.adjust(t.test_13v30_day3$p.value, method = c("fdr"), n = length(VIP_13v30_day3$metabolite)) #Adjust p value for the number of comparisons
t.test_13v30_day3
```

```{r}
t.test_13v30_day3 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #0 significantly different metabolites
```

#### 13_3 vs. 5_3

```{r}
list <- c("13_3", "5_3") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13v5_day3 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13v5_day3 <- as.data.frame(PLSDA.VIP(known.plsda_13v5_day3)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_13v5_day3
```

```{r}
clean_13v5_day3 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13v5_day3 <- cbind(clean_13v5_day3[, 1:4], 
                              log(clean_13v5_day3[, names(clean_13v5_day3) %in% VIP_13v5_day3$metabolite])) %>%
  pivot_longer(., cols = 5:66, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13v5_day3 #Confirm changes
```

```{r}
t.test_13v5_day3 <-do(VIP_select_13v5_day3, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                        alternative = "two.sided",
                                                        mu = 0,
                                                        paired = FALSE,
                                                        var.equal = FALSE,
                                                        conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13v5_day3$p.adj <- p.adjust(t.test_13v5_day3$p.value, method = c("fdr"), n = length(VIP_13v5_day3$metabolite)) #Adjust p value for the number of comparisons
t.test_13v5_day3
```

```{r}
t.test_13v5_day3 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #0 significantly different metabolites
```

### Treatment differences at day 22

#### 13_22 vs. 30_22

```{r}
list <- c("13_22", "30_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13v30_day22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13v30_day22 <- as.data.frame(PLSDA.VIP(known.plsda_13v30_day22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_13v30_day22
```

```{r}
clean_13v30_day22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13v30_day22 <- cbind(clean_13v30_day22[, 1:4], 
                                log(clean_13v30_day22[, names(clean_13v30_day22) %in% VIP_13v30_day22$metabolite])) %>%
  pivot_longer(., cols = 5:55, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13v30_day22 #Confirm changes
```

```{r}
t.test_13v30_day22 <-do(VIP_select_13v30_day22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                            alternative = "two.sided",
                                                            mu = 0,
                                                            paired = FALSE,
                                                            var.equal = FALSE,
                                                            conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13v30_day22$p.adj <- p.adjust(t.test_13v30_day22$p.value, method = c("fdr"), n = length(VIP_13v30_day22$metabolite)) #Adjust p value for the number of comparisons
t.test_13v30_day22
```

```{r}
t.test_13v30_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #29 significantly different metabolites
t.test_13v30_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 > estimate2) %>%
  nrow(.) #16 metabolites higher in 13ºC
t.test_13v30_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 < estimate2) %>%
  nrow(.) #13 metabolites higher in 30ºC
```

```{r}
t.test_13v30_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  left_join(., VIP_13v30_day22, by = "metabolite") %>%
  mutate(., direction = case_when(estimate > 1 ~ "13",
                                  estimate < 1 ~ "30")) %>%
  mutate(., score = case_when(estimate > 1 ~ VIP,
                              estimate < 1 ~ -VIP)) %>%
  arrange(score) %>%
  ggplot(aes(x = score, y = reorder(metabolite, score, sum))) +
  geom_bar(aes(fill = direction), stat = 'identity') +
  xlab("VIP Score") + ylab("Metabolite") +
  scale_x_continuous(limits = c(-2, 2), breaks = seq(-2, 2, 1)) +
  scale_fill_manual(values = c(plotColors[2], plotColors[1]), 
                    name = "Temperature (ºC)",
                    breaks = c("13", "30"),
                    labels = c("13", "30")) +
  theme_classic(base_size = 15) + theme() #Take t-test results and filter out significant metabolites. Create two new columns using estimate values: one for the direction of increase, and another for positive or negative VIP. Arrange by metabolite name and reorder by cumulative VIP score. Plot bars and change x and y axis labels. Add scale information.
ggsave("PLSDA/figures/significant-VIP-13v30-day22.pdf", height = 8.5, width = 11)
```

#### 13_22 vs. 5_22

```{r}
list <- c("13_22", "5_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13v5_day22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13v5_day22 <- as.data.frame(PLSDA.VIP(known.plsda_13v5_day22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_13v5_day22
```

```{r}
clean_13v5_day22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13v5_day22 <- cbind(clean_13v5_day22[, 1:4], 
                               log(clean_13v5_day22[, names(clean_13v5_day22) %in% VIP_13v5_day22$metabolite])) %>%
  pivot_longer(., cols = 5:46, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13v5_day22 #Confirm changes
```

```{r}
t.test_13v5_day22 <-do(VIP_select_13v5_day22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                          alternative = "two.sided",
                                                          mu = 0,
                                                          paired = FALSE,
                                                          var.equal = FALSE,
                                                          conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13v5_day22$p.adj <- p.adjust(t.test_13v5_day22$p.value, method = c("fdr"), n = length(VIP_13v5_day22$metabolite)) #Adjust p value for the number of comparisons
t.test_13v5_day22
```

```{r}
t.test_13v5_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #31 significantly different metabolites
t.test_13v5_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 > estimate2) %>%
  nrow(.) #29 metabolites higher in 13ºC
t.test_13v5_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 < estimate2) %>%
  nrow(.) #2 metabolites higher in 30ºC
```

```{r}
t.test_13v5_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  left_join(., VIP_13v5_day22, by = "metabolite") %>%
  mutate(., direction = case_when(estimate > 1 ~ "13",
                                  estimate < 1 ~ "5")) %>%
  mutate(., score = case_when(estimate > 1 ~ VIP,
                              estimate < 1 ~ -VIP)) %>%
  arrange(score) %>%
  ggplot(aes(x = score, y = reorder(metabolite, score, sum))) +
  geom_bar(aes(fill = direction), stat = 'identity') +
  xlab("VIP Score") + ylab("Metabolite") +
  scale_x_continuous(limits = c(-2.5, 2.5), breaks = seq(-2, 2, 1)) +
  scale_fill_manual(values = c(plotColors[2], plotColors[3]), 
                    name = "Temperature (ºC)",
                    breaks = c("13", "5"),
                    labels = c("13", "5")) +
  theme_classic(base_size = 15) + theme() #Take t-test results and filter out significant metabolites. Create two new columns using estimate values: one for the direction of increase, and another for positive or negative VIP. Arrange by metabolite name and reorder by cumulative VIP score. Plot bars and change x and y axis labels. Add scale information.
ggsave("PLSDA/figures/significant-VIP-13v5-day22.pdf", height = 8.5, width = 11)
```

### Day differences for each treatment

#### 5_3 vs. 5_22

```{r}
list <- c("5_3", "5_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_5_day3v22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_5_day3v22 <- as.data.frame(PLSDA.VIP(known.plsda_5_day3v22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_5_day3v22
```

```{r}
clean_5_day3v22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_5_day3v22 <- cbind(clean_5_day3v22[, 1:4], 
                              log(clean_5_day3v22[, names(clean_5_day3v22) %in% VIP_5_day3v22$metabolite])) %>%
  pivot_longer(., cols = 5:55, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_5_day3v22 #Confirm changes
```

```{r}
t.test_5_day3v22 <-do(VIP_select_5_day3v22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                        alternative = "two.sided",
                                                        mu = 0,
                                                        paired = FALSE,
                                                        var.equal = FALSE,
                                                        conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_5_day3v22$p.adj <- p.adjust(t.test_5_day3v22$p.value, method = c("fdr"), n = length(VIP_5_day3v22$metabolite)) #Adjust p value for the number of comparisons
t.test_5_day3v22
```

```{r}
t.test_5_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #6 significantly different metabolites
t.test_5_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 > estimate2) %>%
  nrow(.) #0 metabolites higher in day 22
t.test_5_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 < estimate2) %>%
  nrow(.) #6 metabolites higher in day 3
```

```{r}
t.test_5_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  left_join(., VIP_5_day3v22, by = "metabolite") %>%
  mutate(., direction = case_when(estimate > 1 ~ "22",
                                  estimate < 1 ~ "3")) %>%
  mutate(., score = case_when(estimate > 1 ~ VIP,
                              estimate < 1 ~ -VIP)) %>%
  arrange(score) %>%
  ggplot(aes(x = score, y = reorder(metabolite, score, sum))) +
  geom_bar(aes(fill = direction), stat = 'identity') +
  xlab("VIP Score") + ylab("Metabolite") +
  scale_x_continuous(limits = c(-2.5, 2.5), breaks = seq(-2, 2, 1)) +
  scale_fill_manual(values = c("black", "purple"), 
                    name = "Day",
                    breaks = c("3", "22"),
                    labels = c("3", "22")) +
  theme_classic(base_size = 15) + theme() #Take t-test results and filter out significant metabolites. Create two new columns using estimate values: one for the direction of increase, and another for positive or negative VIP. Arrange by metabolite name and reorder by cumulative VIP score. Plot bars and change x and y axis labels. Add scale information.
ggsave("PLSDA/figures/significant-VIP-5-day3v22.pdf", height = 8.5, width = 11)
```

#### 13_3 vs. 13_22

```{r}
list <- c("13_3", "13_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13_day3v22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13_day3v22 <- as.data.frame(PLSDA.VIP(known.plsda_13_day3v22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_13_day3v22
```

```{r}
clean_13_day3v22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13_day3v22 <- cbind(clean_13_day3v22[, 1:4], 
                               log(clean_13_day3v22[, names(clean_13_day3v22) %in% VIP_13_day3v22$metabolite])) %>%
  pivot_longer(., cols = 5:61, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13_day3v22 #Confirm changes
```

```{r}
t.test_13_day3v22 <-do(VIP_select_13_day3v22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                          alternative = "two.sided",
                                                          mu = 0,
                                                          paired = FALSE,
                                                          var.equal = FALSE,
                                                          conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13_day3v22$p.adj <- p.adjust(t.test_13_day3v22$p.value, method = c("fdr"), n = length(VIP_13_day3v22$metabolite)) #Adjust p value for the number of comparisons
t.test_13_day3v22
```

```{r}
t.test_13_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #0 significantly different metabolites
```

#### 30_3 vs. 30_22

```{r}
list <- c("30_3", "30_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_30_day3v22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_30_day3v22 <- as.data.frame(PLSDA.VIP(known.plsda_30_day3v22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_30_day3v22
```

```{r}
clean_30_day3v22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_30_day3v22 <- cbind(clean_30_day3v22[, 1:4], 
                               log(clean_30_day3v22[, names(clean_30_day3v22) %in% VIP_30_day3v22$metabolite])) %>%
  pivot_longer(., cols = 5:67, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_30_day3v22 #Confirm changes
```

```{r}
t.test_30_day3v22 <-do(VIP_select_30_day3v22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                          alternative = "two.sided",
                                                          mu = 0,
                                                          paired = FALSE,
                                                          var.equal = FALSE,
                                                          conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_30_day3v22$p.adj <- p.adjust(t.test_30_day3v22$p.value, method = c("fdr"), n = length(VIP_30_day3v22$metabolite)) #Adjust p value for the number of comparisons
t.test_30_day3v22
```

```{r}
t.test_30_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #0 significantly different metabolites
```

# Validate PLSDA model

It's important to validate the PLSDA model. First, I'll run a permutation test to determine how many components to include.

```{r}
MyPerf.plsda <- perf(treatmentday.known.plsda, validation = "Mfold", folds = 6,  
                     progressBar = TRUE, nrepeat = 50) 

plot(MyPerf.plsda, sd = TRUE) #Overall, increasing the number of components decreases the error rate. There doesn't seem to be an exponential reduction of error rate after 3 components.
```

Next, I'll assess the optimal number of metabolites to keep in the analysis.

```{r}
list.keepX <- c(5:10,  seq(20, 300, 10)) #list.keepX # to output the grid of values tested
X <- log(transMetabData[c(5:156)]) #Assign known metabolite data to the X dataframe after log transformation
Y <- as.factor(transMetabData$treatment_day) #Assign treatment data to the Y dataframe
```

```{r}
tune.splsda.srbct <- tune.splsda(X, Y, ncomp = 5, 
                                 validation = 'Mfold', folds = 6,
                                 measure = "BER", test.keepX = list.keepX, nrepeat = 50) #More extensive classification performance
plot(tune.splsda.srbct) #Plot results
```

```{r}
error <- tune.splsda.srbct$error.rate #Save error rate
ncomp <- tune.splsda.srbct$choice.ncomp$ncomp #Optimal number of components based on t-tests on the error rate
ncomp #5 components! That's how many I have

select.keepX <- tune.splsda.srbct$choice.keepX #Optimal number of variables to select (e.g., number of metabolite features)
select.keepX #sPLSDA should be run with 40 features
```

```{r}
myResult.splsda.final_T <- splsda(X, Y, ncomp = ncomp, keepX = select.keepX) #Use the number of components and meatbolites to keep based on optimization from above  
```

```{r}
#pdf("PLSDA/figures/known-metabolites-sPLSDA-day-treatment-comp12.pdf", height = 8.5, width = 11)
plotIndiv(myResult.splsda.final_T, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c("#525252", "grey80", "#CB181D", "salmon", "#2171B5", "lightblue"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "sPLS-DA by Temperature and Day", X.label = "Component 1: 9% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 6% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2")
#dev.off()
```

# WCNA analysis for known metabolites

Although I have lists of VIP associated with each pairwise comparison, there is one additional step I can take to determine which known metabolites are associated with different treatment x day combinations. I will use a Weighted Correlation Network Analysis (similar to a WGCNA for gene expression) to group metabolites together by abundance patterns, then correlate metabolite modules with treatment and day.

```{bash}
mkdir WCNA
mkdir WCNA/figures
```

## Data preparation

### Format data

I need to convert my dataframe such that samples are columns and metabolites are rows. I also need to have a dataframe without metadata.

```{r}
head(rawMetabolomicsData)
head(metabolomicsMetadata)
```

```{r}
rowwiseMetabData <- rawMetabolomicsData %>%
  dplyr::rename(., metabolite = BinBase.name) %>%
  dplyr::select(., -c(2:8)) %>%
  column_to_rownames(., var = "metabolite") %>%
  slice(., c(1:152)) %>%
  log(.) #Take the raw metabolomics data, since that dataframe already has samples in columns and metabolites in rows. Rename the metabolite column, get rid of extraneous data, and change the metabolite column to rownames. Keep only data from known metabolites. Log transform the data.
tail(rowwiseMetabData) #Confirm formatting
```

```{r}
rowSums(dplyr::count(rowwiseMetabData)) > 0 #Check that there are no metabolites with 0 counts for all samples. Should return TRUE.  
```

### Data filtering: PoverA and genefilter

*pOverA*: Specifying the minimum count for a proportion of samples for each metabolite. Here, we are using a pOverA of 0.08. This is because we have 69 samples with a minimum of n = 6 samples per treatment x day. Therefore, we will accept metabolites that are present in 6/69 = 0.08 of the samples because we expect different metabolites by temperature and day as demonstrated by PLSDA analysis. We are further setting the minimum value of metabolites to 0.01 (median normalized), such that 8% of the samples must have a non-zero normalized metabolite presence in order for the metabolite to remain in the data set.  

Filter in the package "genefilter". Pre-filtering our dataset to reduce the memory size dataframe, increase the speed of the transformation and testing functions, and improve quality of statistical analysis by removing low-coverage counts. Removed counts could represent outliers in the data and removing these improves sensitivity of statistical tests.

```{r}
filt <- filterfun(pOverA(0.08, 0.01)) #Define the filter
gfilt <- genefilter(rowwiseMetabData, filt) #Create filter for the metabolite data
```

```{r}
keep <- rowwiseMetabData[gfilt,] #Identify metabolites to keep by count filter
n.keep <- rownames(keep) #Identify metabolite lists

rowwiseMetabData_filt <- as.data.frame(rowwiseMetabData[which(rownames(rowwiseMetabData) %in% n.keep),]) #Metabolite count data filtered in PoverA, P percent of the samples have counts over A
```

```{r}
#How many rows do we have before and after filtering?
nrow(rowwiseMetabData) #Before
nrow(rowwiseMetabData_filt) #After
```

All 152 metabolites will be used in downstream analysis.

```{r}
#Checking that all row and column names match. Should return "TRUE"
all(rownames(metabolomicsMetadata$sample_id) %in% colnames(rowwiseMetabData_filt))
all(rownames(metabolomicsMetadata$sample_id) == colnames(rowwiseMetabData_filt)) 
```

### Outlier detection

I will identify outliers visually through a clustering analysis.

```{r}
sampleTree <- hclust(dist(rowwiseMetabData), method = "average") #Perform clustering analysis
```

```{r}
#pdf("WCNA/figures/metabolite-outliers.pdf", height = 8.5, width = 11)
plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 0.8, cex.axis = 0.8, cex.main = 2) #Plot cluster dendogram
#dev.off()
```

Based on the tree, taurine and sulfuric acid might be outliers.

```{r}
rowwiseMetabData %>% filter(., rownames(.) == "taurine")
rowwiseMetabData %>% filter(., rownames(.) == "sulfuric acid")
```

```{r}
rowwiseMetabData <- t(rowwiseMetabData) %>% as.data.frame(.) #Transpose such that samples are in rows and metabolites are in columns.  
head(rowwiseMetabData) #Confirm changes
```

Construct a new cluster dendogram to visually identify sample outliers.

```{r}
sampleTree <- hclust(dist(rowwiseMetabData), method = "average") #Perform clustering analysis
```

```{r}
#pdf("WCNA/figures/sample-outliers.pdf", height = 8.5, width = 11)
plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
#dev.off()
```

There don't seem to be any samples that look like outliers (but it's also interesting how there isn't a clear separation of samples by tank or treatment).

## Network construction and consensus module detection

### Choosing a soft-thresholding power: Analysis of a network topology β  

The soft thresholding power (β) is the number to which the co-expression similarity is raised to calculate adjacency. The function `pickSoftThreshold` performs a network topology analysis. The user chooses a set of candidate powers, however the default parameters are suitable values.  

```{r, message=FALSE, warning=FALSE}
allowWGCNAThreads()
powers <- c(c(1:20), seq(from = 12, to=20, by=2)) #Create a string of numbers from 1 through 10, and even numbers from 10 through 20
sft <-pickSoftThreshold(rowwiseMetabData, powerVector = powers, verbose = 5) # Call the network topology analysis function
```

```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# # # Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# # # this line corresponds to using an R^2 cut-off
abline(h=0.85,col="red")
# # # Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

When choosing a soft thresholding power, want to choose the lowest number that reaches the R<sup>2</sup> cutoff. From this data, it appears that the **soft thresholding power is 6**.  

### Identify modules using `blockwiseModules`  

Use `blockwiseModules` to identify modules of metabolites.  

Settings used: 

networkType = "unsigned" 
deepSplit = 2
pamRespectsDendro = F
minModuleSize = 5
maxBlockSize = 4000
reassignThreshold = 0
mergeCutHeight = 0.25

```{r, echo=TRUE, warning=FALSE, message=FALSE}

picked_power = 6
temp_cor <- cor       
cor <- WGCNA::cor # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(rowwiseMetabData,                         # <= input here
                          
                          # == Adjacency Function ==
                          power = picked_power,               # <= power here
                          networkType = "unsigned",
                          
                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,                  
                          maxBlockSize = 4000,
                          
                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,
                          
                          # == TOM == Archive the run results in TOM file (saves time) but it doesn't save a file
                          saveTOMs = F,
                          saveTOMFileBase = "ER",
                          
                          # == Output Options
                          numericLabels = T,
                          verbose = 3)

cor <- temp_cor     # Return cor function to original namespace
```

```{r}
mergedColors = netwk$colors # Identify labels as numbers 
table(mergedColors)
```

Module sizes are as follows: 

0  1  2  3  4  5  6  7  8 
40 22 22 19 15 10 10  8  6 

```{r}
# Plot the dendrogram and the module colors underneath

#pdf("WCNA/figures/cluster-dendogram-mergedME.pdf")
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
#dev.off()
```

### Relate modules to sample information

``` {r, echo=TRUE, warning=FALSE, message=FALSE}
module_df <- data.frame(
  Metabolite = names(netwk$colors),
  colors = netwk$colors
  #colors = labels2colors(netwk$colors)
)

module_df[1:5,]

write.csv(module_df, "WCNA/metabolite_modules.csv")

# Get Module Eigengenes per cluster
MEs <- moduleEigengenes(rowwiseMetabData, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs <- orderMEs(MEs)
module_order = names(MEs) %>% gsub("ME","", .)

# Add Sample names
MEs0 <- MEs
MEs0$crab.ID = row.names(MEs)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-crab.ID) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=crab.ID, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-Sample Relationships", y = "Modules", fill="corr")
```

### Relate modules to treatment and day

Prepare trait data. Data has to be numeric, so I will substitute temperatures and days for numeric values. TMake a dataframe that has a column for each treatment or day and a row for samples. Populate a 1 for samples that match each treatment or day and a 0 for samples not matching respective treatments or days This process changes treatments and days from a categorical variable into a binary variable. This will allow for correlations between mean eigengenes and treatment or day.  

```{r}
head(metabolomicsMetadata)
```

```{r}
datTraits <- metabolomicsMetadata %>%
  mutate(., "13ºC at Day 3" = case_when(treatment_day == "13_3" ~ 1,
                                        treatment_day != "13_3" ~ 0)) %>%
  mutate(., "5ºC at Day 3" = case_when(treatment_day == "5_3" ~ 1,
                                       treatment_day != "5_3" ~ 0)) %>%
  mutate(., "30ºC at Day 3" = case_when(treatment_day == "30_3" ~ 1,
                                        treatment_day != "30_3" ~ 0)) %>%
  mutate(., "13ºC at Day 22" = case_when(treatment_day == "13_22" ~ 1,
                                         treatment_day != "13_22" ~ 0)) %>%
  mutate(., "5ºC at Day 22" = case_when(treatment_day == "5_22" ~ 1,
                                        treatment_day != "5_22" ~ 0)) %>%
  mutate(., "30ºC at Day 22" = case_when(treatment_day == "30_22" ~ 1,
                                         treatment_day != "30_22" ~ 0)) %>%
  dplyr::select(., -c(2:4)) #Copy dataframe into datTraits, then use a series of case_when commands to create individual columns for each treatment or day, with 1 indicating that sample is part of the group, and 0 indicating that sample is not part of the group. Remove previous treatment classification columns. 
rownames(datTraits) <- datTraits$crab.ID #Convert crab.ID into rownames.
datTraits <- datTraits %>%
  dplyr::select(., -crab.ID) #Remove the crab.ID column
head(datTraits) #Confirm dataframe creation
```

```{r}
#Define numbers of metabolites and samples and view 
nMetabolites <- ncol(rowwiseMetabData)
nSamples <- nrow(rowwiseMetabData)

nMetabolites
nSamples
```

We have 152 metabolites and 69 samples.   

Next correlate the trait matrix (treatment, day) with eigengenes (modules).  

```{r}
moduleTraitCor <- cor(MEs, datTraits, use = "p") #Correlations of traits with eigengenes
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples) #Get p-values for correlations
head(moduleTraitCor %>% as.data.frame())
head(moduleTraitPvalue %>% as.data.frame())
```

```{r}
moduleTraitTree <- hclust(dist(t(moduleTraitCor)), method = "average") #Create cluster dendogram for module-trait correlations
```

```{r}
#pdf(file = "WCNA/figures/module-trait-cluster-dendogram.pdf", height = 8.5, width = 11)
plot(moduleTraitTree) #Plot cluster dendogram
#dev.off()
```

```{r}
# Correlations of metabolites with eigengenes. Calculate correlations between ME's and groups 
moduleGeneCor <- cor(MEs, rowwiseMetabData) #Correlate eigengenes with metabolites
moduleGenePvalue <- corPvalueStudent(moduleGeneCor, nSamples) #Calculate p-values for metabolite-eigengene correlations
head(moduleGeneCor %>% as.data.frame)
head(moduleGenePvalue %>% as.data.frame(.))
```

## Plot module-trait associations

```{r, echo=TRUE, warning=FALSE, message=FALSE}
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",signif(moduleTraitPvalue, 1), ")", sep = "") #Create a matrix with the module-trait correlation and p-values
dim(textMatrix) <- dim(moduleTraitCor) #Ensure this matrix has the appropriate dimensions
head(textMatrix) #Confirm matrix creation
```

```{r}
#pdf("WCNA/figures/module-trait-relationships.pdf", height = 8.5, width = 11)
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y = 1.5, cex.lab.x = 1.5, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 1, zlim = c(-1,1), main = paste("Module-trait relationships"), cex.main = 2) #Use the textMatrix to create a heatmap with correlations between modules and the various treatments.
#dev.off()
```

```{r, echo=TRUE, warning=FALSE, message=FALSE}
heatmappval <- signif(moduleTraitPvalue, 1) #Create list of pvalues for eigengene correlation with specific traits

row_dend <- dendsort(hclust(dist(moduleTraitCor))) #Create dendograms for rows
col_dend <- dendsort(hclust(dist(t(moduleTraitCor)))) #Create dendograms for columns

trait_order <- c("5ºC at Day 3", "13ºC at Day 3", "30ºC at Day 3", "5ºC at Day 22", "13ºC at Day 22", "30ºC at Day 22") #Order of traits for heatmap
```

```{r}
#pdf(file = "WCNA/figures/module-trait-relationship-heatmap.pdf", height = 8.5, width = 8.5)
ht <- Heatmap(moduleTraitCor, name = "Eigengene", column_title = "Module-Group Eigengene Correlation",
              col = blueWhiteRed(50), 
              row_names_side = "left", 
              row_dend_side = "left",
              width = unit(5, "in"), 
              height = unit(4.5, "in"), 
              column_dend_reorder = TRUE, 
              cluster_columns = col_dend,
              row_dend_reorder = FALSE,  
              #column_split = 3, 
              #row_split = 3, 
              #column_dend_height = unit(.5, "in"),
              cluster_rows = row_dend, 
              #column_order = trait_order, 
              #row_gap = unit(2.5, "mm"), 
              border = TRUE,
              cell_fun = function(j, i, x, y, w, h, col) {
                if(heatmappval[i, j] < 0.05) {
                  grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
                }
                else {
                  grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
                }},
              column_names_rot = 45,
              column_names_gp =  gpar(fontsize = 12, border = FALSE),
              column_title_gp = gpar(fontsize = 20),
              row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE)) #Create a heatmap object
draw(ht) #Draw heatmap
#dev.off()
```

## Plot mean eigengene values for each module

```{r}
#Ensure metadata columns are factors
metabolomicsMetadata$crab.ID <- as.factor(metabolomicsMetadata$crab.ID)
metabolomicsMetadata$treatment <- as.factor(metabolomicsMetadata$treatment)
metabolomicsMetadata$day <- as.factor(metabolomicsMetadata$day)
metabolomicsMetadata$treatment_day <- as.factor(metabolomicsMetadata$treatment_day)
```

```{r}
mME_meta <- merge(mME, metabolomicsMetadata, by = "crab.ID") %>%
  rename(Module = name) #Create new dataframe with metadata
head(mME_meta) #Confirm dataframe creation
mME_meta$treatment_day <- factor(mME_meta$treatment_day, levels = c("5_3", "5_22", 
                                                                    "13_3", "13_22", 
                                                                    "30_3", "30_22")) #Reorder levels
levels(mME_meta$treatment_day) #Confirm levels were reordered
```

```{r}
write.csv(WCNA/mME_meta, "module-expression.csv", quote = FALSE, row.names = FALSE) #Save module expression dataframe
```

First, I'm going to look at boxplots for eigengene expression by treatment x day.

```{r, warning = FALSE, message = FALSE}
#pdf("WCNA/figures/eigengene-expression-boxplot.pdf", height = 8.5, width = 11)
mME_meta %>%
  ggplot(aes(x = treatment_day, y = value, colour = treatment_day)) +
  facet_wrap(~ Module) +
  ylab("Module Expression") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey")+
  geom_boxplot(width = 0.5, position = position_dodge(width = 0.5), alpha = 0.7) +
  stat_summary(fun=mean, geom="line", aes(group = treatment_day, color = treatment_day), position = position_dodge(width = 0.5))  + 
  geom_point(pch = 21, position = position_dodge(width = 0.5)) +
  scale_fill_manual(name = "Temperature (ºC) x Day", 
                    values = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"),
                    labels = c("5ºC on Day 3", "5ºC on Day 22", "13ºC on Day 3", "13ºC on Day 22", "30ºC on Day 3", "30ºC on Day 22")) +
  scale_colour_manual(name = "Temperature (ºC) x Day", 
                      values = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"),
                      labels = c("5ºC on Day 3", "5ºC on Day 22", "13ºC on Day 3", "13ºC on Day 22", "30ºC on Day 3", "30ºC on Day 22")) +
  xlab("") + #Axis titles
  theme_classic(base_size = 15) + theme(axis.text.x = element_text(color = "white"),
                                        axis.ticks.x = element_blank()) #Create a boxplot with data points for module expression on the y-axis and values for each treatment x day combination. Facet by module eigengene. Add a horizontal line at y = 0.
#dev.off()
```

I'm going to make a similar plot, but use dots instead to see if that makes the trends clearer.

```{r}
#pdf("WCNA/figures/eigengene-expression-dotplot.pdf", height = 8.5, width = 11)
mME_meta %>%
  ggplot(aes(x = treatment_day, y = value)) +
  facet_grid(~Module) +
  ylab("Eigengene Expression") +
  geom_hline(yintercept = 0, linetype ="dashed", color = "grey")+
  geom_point(aes(fill = treatment_day, color = treatment_day), size = 3, pch = 21, position = position_dodge(width = 0.5)) +
  geom_smooth(aes(group=1), se=TRUE, show.legend = NA, color="black")+
  scale_fill_manual(name = "Temperature (ºC) x Day", 
                    values = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"),
                    labels = c("5ºC on Day 3", "5ºC on Day 22", "13ºC on Day 3", "13ºC on Day 22", "30ºC on Day 3", "30ºC on Day 22")) +
  scale_colour_manual(name = "Temperature (ºC) x Day", 
                      values = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"),
                      labels = c("5ºC on Day 3", "5ºC on Day 22", "13ºC on Day 3", "13ºC on Day 22", "30ºC on Day 3", "30ºC on Day 22")) +
  xlab("") + #Axis titles
  theme_classic(base_size = 15) + theme(axis.text.x = element_blank(), 
                                        axis.ticks.x = element_blank(),
                                        legend.position = "bottom", 
                                        legend.text = element_text(color = "black", size = 12), 
                                        strip.text.x = element_text(size = 14, color = "black", face="bold"))
#dev.off()
```

```{r}
mME_meta$treatment_day <- factor(mME_meta$treatment_day, levels = c("13_3", "13_22", 
                                                                    "5_3", "5_22", 
                                                                    "30_3", "30_22")) #Reorder levels
levels(mME_meta$treatment_day) #Confirm levels were reordered
```


```{r}
metab_rel_change <- mME_meta %>%
  dplyr::select(treatment_day, crab.ID, Module, value) %>%
  group_by(treatment_day, Module) %>%
  summarise(mean = mean(value)) %>%
  group_by(treatment_day, Module) %>%
  arrange(treatment_day, .by_group = TRUE) %>%
  group_by(Module) %>%
  mutate(metabolite_expression = ((mean-dplyr::first(mean))/abs(dplyr::first(mean)))) %>%
  dplyr::select(Module, treatment_day, metabolite_expression) #Take the dataframe with module information and metadata, and keep only the treatment_day, crab.ID, module, and module eigengene values. Group by treatment_day and Module, then calculate mean eigengene expression. Arrange by treatment_day, group by module again, then calculaterelative change in expression for each module relative to 13ºC at day 3. 
metab_rel_change #Confirm calculations
```

```{r}
write.csv(WCNA/metab_rel_change, "metabolites_relative_change.csv", quote = FALSE, row.names = FALSE)
```

# Pathway analysis with MetaboAnalyst

The final step in this workflow is to understand the various metabolic pathways represented in each module eigengene. I'll conduct the majority of this analysis with the MetaboAnalyst GUI interface, but return here to process results.

```{bash}
mkdir metaboanalyst
mkdir metaboanalyst/figures
```

## Create lists of metabolites in each module

For each module, I want the metabolite name, but I also want all of the PubChem and KEGG ID information provided by the sequencing facility. This is because common names for metabolties can be different, and using a numerical classifier will ensure the correct compounds are recognized by MetaboAnalyst.

```{r}
module0_metabolites <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 0) %>%
  dplyr::select(., Metabolite) %>% 
  left_join(., (rawMetabolomicsData %>% dplyr::rename(Metabolite = BinBase.name)), by = "Metabolite") %>%
  dplyr::select(., Metabolite, PubChem, KEGG) #Take dataframe with modules and metabolites, change colors to Module, and select metabolites for a given module. Keep only the metabolite column. Then join with the raw metabolomics data to get PubChem and KEGG ids.
nrow(module0_metabolites) #40 metabolites
head(module0_metabolites)
write.csv(module0_metabolites, "metaboanalyst/module0_metabolites.csv", quote = FALSE, row.names = FALSE)
```

```{r}
module1_metabolites <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 1) %>%
  dplyr::select(., Metabolite) %>% 
  left_join(., (rawMetabolomicsData %>% dplyr::rename(Metabolite = BinBase.name)), by = "Metabolite") %>%
  dplyr::select(., Metabolite, PubChem, KEGG) #Take dataframe with modules and metabolites, change colors to Module, and select metabolites for a given module. Keep only the metabolite column. Then join with the raw metabolomics data to get PubChem and KEGG ids.
nrow(module1_metabolites) #22 metabolites
head(module1_metabolites)
write.csv(module1_metabolites, "metaboanalyst/module1_metabolites.csv", quote = FALSE, row.names = FALSE)
```

```{r}
module2_metabolites <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 2) %>%
  dplyr::select(., Metabolite) %>% 
  left_join(., (rawMetabolomicsData %>% dplyr::rename(Metabolite = BinBase.name)), by = "Metabolite") %>%
  dplyr::select(., Metabolite, PubChem, KEGG) #Take dataframe with modules and metabolites, change colors to Module, and select metabolites for a given module. Keep only the metabolite column. Then join with the raw metabolomics data to get PubChem and KEGG ids.
nrow(module2_metabolites) #22 metabolites
head(module2_metabolites)
write.csv(module2_metabolites, "metaboanalyst/module2_metabolites.csv", quote = FALSE, row.names = FALSE)
```

```{r}
module3_metabolites <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 3) %>%
  dplyr::select(., Metabolite) %>% 
  left_join(., (rawMetabolomicsData %>% dplyr::rename(Metabolite = BinBase.name)), by = "Metabolite") %>%
  dplyr::select(., Metabolite, PubChem, KEGG) #Take dataframe with modules and metabolites, change colors to Module, and select metabolites for a given module. Keep only the metabolite column. Then join with the raw metabolomics data to get PubChem and KEGG ids.
nrow(module3_metabolites) #19 metabolites
head(module3_metabolites)
write.csv(module3_metabolites, "metaboanalyst/module3_metabolites.csv", quote = FALSE, row.names = FALSE)
```

```{r}
module4_metabolites <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 4) %>%
  dplyr::select(., Metabolite) %>% 
  left_join(., (rawMetabolomicsData %>% dplyr::rename(Metabolite = BinBase.name)), by = "Metabolite") %>%
  dplyr::select(., Metabolite, PubChem, KEGG) #Take dataframe with modules and metabolites, change colors to Module, and select metabolites for a given module. Keep only the metabolite column. Then join with the raw metabolomics data to get PubChem and KEGG ids.
nrow(module4_metabolites) #15 metabolites
head(module4_metabolites)
write.csv(module4_metabolites, "metaboanalyst/module4_metabolites.csv", quote = FALSE, row.names = FALSE)
```

```{r}
module5_metabolites <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 5) %>%
  dplyr::select(., Metabolite) %>% 
  left_join(., (rawMetabolomicsData %>% dplyr::rename(Metabolite = BinBase.name)), by = "Metabolite") %>%
  dplyr::select(., Metabolite, PubChem, KEGG) #Take dataframe with modules and metabolites, change colors to Module, and select metabolites for a given module. Keep only the metabolite column. Then join with the raw metabolomics data to get PubChem and KEGG ids.
nrow(module5_metabolites) #10 metabolites
head(module5_metabolites)
write.csv(module5_metabolites, "metaboanalyst/module5_metabolites.csv", quote = FALSE, row.names = FALSE)
```

```{r}
module6_metabolites <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 6) %>%
  dplyr::select(., Metabolite) %>% 
  left_join(., (rawMetabolomicsData %>% dplyr::rename(Metabolite = BinBase.name)), by = "Metabolite") %>%
  dplyr::select(., Metabolite, PubChem, KEGG) #Take dataframe with modules and metabolites, change colors to Module, and select metabolites for a given module. Keep only the metabolite column. Then join with the raw metabolomics data to get PubChem and KEGG ids.
nrow(module6_metabolites) #10 metabolites
head(module6_metabolites)
write.csv(module6_metabolites, "metaboanalyst/module6_metabolites.csv", quote = FALSE, row.names = FALSE)
```

```{r}
module7_metabolites <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 7) %>%
  dplyr::select(., Metabolite) %>% 
  left_join(., (rawMetabolomicsData %>% dplyr::rename(Metabolite = BinBase.name)), by = "Metabolite") %>%
  dplyr::select(., Metabolite, PubChem, KEGG) #Take dataframe with modules and metabolites, change colors to Module, and select metabolites for a given module. Keep only the metabolite column. Then join with the raw metabolomics data to get PubChem and KEGG ids.
nrow(module7_metabolites) #8 metabolites
head(module7_metabolites)
write.csv(module7_metabolites, "metaboanalyst/module7_metabolites.csv", quote = FALSE, row.names = FALSE)
```

```{r}
module8_metabolites <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 8) %>%
  dplyr::select(., Metabolite) %>% 
  left_join(., (rawMetabolomicsData %>% dplyr::rename(Metabolite = BinBase.name)), by = "Metabolite") %>%
  dplyr::select(., Metabolite, PubChem, KEGG) #Take dataframe with modules and metabolites, change colors to Module, and select metabolites for a given module. Keep only the metabolite column. Then join with the raw metabolomics data to get PubChem and KEGG ids.
nrow(module8_metabolites) #6 metabolites
head(module8_metabolites)
write.csv(module8_metabolites, "metaboanalyst/module8_metabolites.csv", quote = FALSE, row.names = FALSE)
```

## Enrichment compound class analysis

### Analysis in MetaboAnalyst interface

The first kind of enrichment analysis I will complete is looking at compound structures. To do this, I will upload the list of metabolite names for each module (generated above) to the [MetaboAnalyst interface](https://www.metaboanalyst.ca/MetaboAnalyst/upload/EnrichUploadView.xhtml). Then, I will conduct an enrichment of *main class chemical structures*. 

> Enrichment tests are based on the well-established globaltest to test associations between metabolite sets and the outcome. The algorithm uses a generalized linear model to compute a ‘Q-stat’ for each metabolite set. The Q-stat is calculated as the average of the Q values calculated for the each single metabolites; while the Q value is the squared covariance between the metabolite and the outcome. The globaltest has been shown to exhibit similar or superior performance when tested against several other popular methods.

> Metabolite sets: Unlike transcriptomics which allows comprehensive gene expression profiling, targeted metabolomics usually covers only a small percentage of metabolome (the actual coverage is platform/protocol specific). This means that metabolites (defined in our current pathways or metabolite sets) do not have equal probabilities of being measured in your studies, and the enriched functions are the results from both platform/protocol specific effects and biological perturbations. Since the primary interest is to detect the latter, we highly recommend uploading a reference metabolome containing all measurable metabolites from your platform to eliminate the former effects.

I don't have a reference metabolome and I didn't perform targeted metabolomics. I used metabolite sets containing at least two entries and all compounds in the selected library as a reference.

Certain compounds were not recognized by MetaboAnalyst, or require manual PubChem/KEGG ID correction. The resulting name maps (input names v.s names used for enrichment analysis) from MetaboAnalyst were renamed according to module number and saved [here](https://github.com/yaaminiv/green-crab-metabolomics/tree/main/output/05-metabolomics-analysis/metaboanalyst/name-maps).

The output tables (msea_ora_result.csv files from MetaboAnalyst) were renamed according to module number and saved [here](https://github.com/yaaminiv/green-crab-metabolomics/tree/main/output/05-metabolomics-analysis/metaboanalyst/msea-compoundClass/enrichment-output).

### View results

#### Import results

```{r}
#Import dataframes from each module. Add a Module column and rename the first column.

module0_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module0-msea_ora_result.csv") %>%
  mutate(., Module = "0") %>%
  dplyr::rename(., compoundClass = X)
module1_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module1-msea_ora_result.csv") %>%
  mutate(., Module = "1") %>%
  dplyr::rename(., compoundClass = X)
module2_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module2-msea_ora_result.csv") %>%
  mutate(., Module = "2") %>%
  dplyr::rename(., compoundClass = X)
module3_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module3-msea_ora_result.csv") %>%
  mutate(., Module = "3") %>%
  dplyr::rename(., compoundClass = X)
module4_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module4-msea_ora_result.csv") %>%
  mutate(., Module = "4") %>%
  dplyr::rename(., compoundClass = X)
module5_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module5-msea_ora_result.csv") %>%
  mutate(., Module = "5") %>%
  dplyr::rename(., compoundClass = X)
module6_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module6-msea_ora_result.csv") %>%
  mutate(., Module = "6") %>%
  dplyr::rename(., compoundClass = X)
module7_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module7-msea_ora_result.csv") %>%
  mutate(., Module = "7") %>%
  dplyr::rename(., compoundClass = X)
module8_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module8-msea_ora_result.csv") %>%
  mutate(., Module = "8") %>%
  dplyr::rename(., compoundClass = X)
```

```{r}
compound_classes <- rbind(module0_class,
                          module1_class,
                          module2_class,
                          module3_class,
                          module4_class,
                          module5_class,
                          module6_class,
                          module7_class,
                          module8_class) #Create dataframe with compound classes
head(compound_classes) #Confirm dataframe creation
```

```{r}
write.csv(compound_classes, "metaboanalyst/msea-compoundClass/all-module-compound-classes.csv", quote = FALSE, row.names = FALSE) #Save dataframe with all compound classes for all modules
```

#### Format results

```{r}
sig_classes_comp <- compound_classes %>%
  filter(., FDR < 0.05) %>%
  dplyr::select(., compoundClass, total, hits, FDR, Module) #Filter out only significant compound classes using a FDR < 0.05 threshold. Keep compoundClass, total, hits, FDR, and Module columns.
head(sig_classes_comp) 
```

```{r}
write.csv(sig_classes_comp, "metaboanalyst/msea-compoundClass/significant-compound-classes.csv", quote = FALSE, row.names = FALSE)
```

#### Plot results

```{r}
ggplot(sig_classes_comp, aes(x = Module, y = compoundClass)) + 
  geom_point(aes(size = hits)) +
  scale_size(name = "Metabolites",
             range = c(4,15), 
             limits = c(1,15)) +
  xlab("Module Eigengene") + ylab("Compound Class") +
  theme_classic(base_size = 15) #Plot significantly enriched compound classes for each module. Scale point size by the number of metabolite hits in each category. Define x- and y- axis labels. Change the angle of the x-axis text.
ggsave("metaboanalyst/figures/compound-class-dotplot.pdf", height = 8.5, width = 11)
```

## KEGG Pathway Analysis

### Analysis in MetaboAnalyst Interface

I'll return to the [MetaboAnalyst enrichment interface](https://www.metaboanalyst.ca/MetaboAnalyst/upload/EnrichUploadView.xhtml) and use the same steps to conduct a KEGG Pathway enrichment. Again, I will upload metabolite names and correct them as needed within the interface. KEGG Pathway enrichment results are saved [here](https://github.com/yaaminiv/green-crab-metabolomics/tree/main/output/05-metabolomics-analysis/metaboanalyst/msea-KEGG/enrichment-output).

### View results

#### Import results

```{r}
#Import dataframes from each module. Add a Module column and rename the first column.

module0_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module0-msea_ora_result.csv") %>%
  mutate(., Module = "0") %>%
  dplyr::rename(., KEGG = X)
module1_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module1-msea_ora_result.csv") %>%
  mutate(., Module = "1") %>%
  dplyr::rename(., KEGG = X)
module2_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module2-msea_ora_result.csv") %>%
  mutate(., Module = "2") %>%
  dplyr::rename(., KEGG = X)
module3_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module3-msea_ora_result.csv") %>%
  mutate(., Module = "3") %>%
  dplyr::rename(., KEGG = X)
module4_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module4-msea_ora_result.csv") %>%
  mutate(., Module = "4") %>%
  dplyr::rename(., KEGG = X)
module5_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module5-msea_ora_result.csv") %>%
  mutate(., Module = "5") %>%
  dplyr::rename(., KEGG = X)
# module6_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module6-msea_ora_result.csv") %>%
#   mutate(., Module = "6") %>%
#   dplyr::rename(., KEGG = X)
module7_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module7-msea_ora_result.csv") %>%
  mutate(., Module = "7") %>%
  dplyr::rename(., KEGG = X)
# module8_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module8-msea_ora_result.csv") %>%
#   mutate(., Module = "8") %>%
#   dplyr::rename(., KEGG = X)
```

```{r}
KEGG_pathways <- rbind(module0_KEGG,
                       module1_KEGG,
                       module2_KEGG,
                       module3_KEGG,
                       module4_KEGG,
                       module5_KEGG,
                       # module6_KEGG,
                       module7_KEGG
                       # module8_KEGG
                       ) #Create dataframe with compound classes
head(KEGG_pathways) #Confirm dataframe creation
```

```{r}
write.csv(KEGG_pathways, "metaboanalyst/msea-KEGG/all-module-KEGG-pathways.csv", quote = FALSE, row.names = FALSE) #Save dataframe with all compound classes for all modules
```

#### Format results

```{r}
sig_KEGG_pathways <- KEGG_pathways %>%
  filter(., FDR < 0.05) %>%
  dplyr::select(., KEGG, total, hits, FDR, Module) #Filter out only significant compound classes using a FDR < 0.05 threshold. Keep KEGG, total, hits, FDR, and Module columns.
head(sig_KEGG_pathways) 
```

```{r}
write.csv(sig_KEGG_pathways, "metaboanalyst/msea-KEGG/significant-compound-classes.csv", quote = FALSE, row.names = FALSE)
```

#### Plot results

```{r}
ggplot(sig_KEGG_pathways, aes(x = Module, y = KEGG)) + 
  geom_point(aes(size = hits)) +
  scale_size(name = "Metabolites",
             range = c(4,15), 
             limits = c(1,15)) +
  xlab("Module Eigengene") + ylab("KEGG Pathway") +
  theme_classic(base_size = 15) #Plot significantly enriched KEGG pathways for each module. Scale point size by the number of metabolite hits in each category. Define x- and y- axis labels. Change the angle of the x-axis text.
ggsave("metaboanalyst/figures/KEGG-pathway-dotplot.pdf", height = 8.5, width = 11)
```

**TO DO**:

- figure out why modules 6 and 8 aren't running through KEGG enrichment


