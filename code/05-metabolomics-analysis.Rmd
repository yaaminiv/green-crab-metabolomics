---
title: "04-respirometry-analysis"
author: "Yaamini Venkataraman"
date: '2023-12-18'
output: html_document
---

In this script, I will analyze metabolomics data from the West Coast Metabolomics Center (UC Davis). I will conduct an initial assessment of the data (PLS-DA), understand important metabolites and pathways (VIP analysis and WGCNA), and prepare for additional network analysis through MetaboAnalyst. This workflow and script is modified from [Huffmyer et al. (2023)](https://www.biorxiv.org/content/10.1101/2023.03.20.533475v2.full) and [Trigg et al. (2019)](http://dx.doi.org/10.1038/s41598-019-46947-6).

# Set up R Markdown document

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath("../output/05-metabolomics-analysis/")) #Set root directory
```

```{r}
getwd()
```

# Install packages

```{r packages, warning = FALSE, message = FALSE}
# if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse') 
# if ("vegan" %in% rownames(installed.packages()) == 'FALSE') install.packages('vegan') 
# if ("factoextra" %in% rownames(installed.packages()) == 'FALSE') install.packages('factoextra') 
# if ("ggfortify" %in% rownames(installed.packages()) == 'FALSE') install.packages('ggfortify') 
# if ("naniar" %in% rownames(installed.packages()) == 'FALSE') install.packages('naniar') 
# if ("cowplot" %in% rownames(installed.packages()) == 'FALSE') install.packages('cowplot') 
# if (!requireNamespace("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# if ("mixOmics" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("mixOmics") 
# if ("RVAideMemoire" %in% rownames(installed.packages()) == 'FALSE') install.packages('RVAideMemoire') 
# if ("VennDiagram" %in% rownames(installed.packages()) == 'FALSE') install.packages('VennDiagram') 
# if ("broom" %in% rownames(installed.packages()) == 'FALSE') install.packages('broom') 
# if ("RColorBrewer" %in% rownames(installed.packages()) == 'FALSE') install.packages('RColorBrewer') 
# if ("pheatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('pheatmap') 
# if ("genefilter" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("genefilter") 
# if ("WGCNA" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('WGCNA')
if ("dendsort" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('dendsort') 
if ("ComplexHeatmap" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ComplexHeatmap') 

require(tidyverse)
require(vegan)
# require(factoextra)
# require(ggfortify)
# require(naniar)
# require(cowplot)
require(mixOmics)
require(RVAideMemoire)
# require(VennDiagram)
require(broom)
require(RColorBrewer)
require(pheatmap)
require(genefilter)
require(WGCNA)
require(dendsort)
require(ComplexHeatmap)
```

```{r}
source("../../code/biostats.R") #Source multivariate analysis functions
```

```{r}
sessionInfo()
```

# Import data

```{r}
rawMetabolomicsData <- read.csv("../../data/raw_metabolomics_data.csv", header = TRUE) %>% 
  dplyr::rename_with(~stringr::str_replace_all(., "X", "")) #Import data. Remove the "X" prefix for crab IDs
head(rawMetabolomicsData) #Confirm import
```

```{r}
metabolomicsMetadata <- read.csv("../../data/metabolomics_metadata.csv", header = FALSE, strip.white = TRUE) %>% 
  dplyr::rename_with(~stringr::str_replace_all(., "V", "")) %>%
  t(.) %>% as.data.frame(.) %>% 
  purrr::set_names(as.character(dplyr::slice(., 1))) %>%
  dplyr::slice(., -1) %>% 
  mutate(., unite(., "treatment_day", treatment:day, sep = "_")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = "_  3", replacement = "_3")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = "_ 22", replacement = "_22")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = " 13_", replacement = "13_")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = " 30_", replacement = "30_")) %>%
  mutate(., treatment_day = gsub(x = treatment_day, pattern = "  5_", replacement = "5_")) #Import metadata. Do not include any header information. Remove "V" from column names. Transform so crab.ID, treatment, and day are all columns. Set the first row in the dataframe as column names, then remove that row.
tail(metabolomicsMetadata) #Confirm import
```

# Format data

Before analyzing the data, I will transform the data and match with treatment metadata. The West Coast Metabolomics Center has already normalized data using the average mTIC (sum of all peak heights for *identified* metabolites) of the samples, and I will not perform any additional normalizations. 

```{r}
transMetabData <- rawMetabolomicsData %>%
  dplyr::select(., -c(2:8)) %>%
  column_to_rownames(., var = "BinBase.name") %>%
  t(.) %>% as.data.frame(.) %>%
  rownames_to_column(., var = "crab.ID") %>% 
  left_join(metabolomicsMetadata, ., by = "crab.ID") #Remove columns with MS information, convert BinBase.name to rownames, and transform dataframe. Convert rownames to crab.ID column
head(transMetabData) #Confirm changes
```

# Initial data investigation with PCA

```{r}
scaled.pca <- prcomp(transMetabData[c(5:601)], scale = TRUE, center = TRUE) #Use prcomp to perform a centered and scaled PCA calculation
summary(scaled.pca) #Standard deviations for each PC
```

```{r PCA interpretation}
pca.eigenval(scaled.pca) #Eigenvalues greater than the broken-stick expectation are considered to explain a statistically significance proportion of the variance in the original dataset. PC3 and PC4 eigenvalue > BSV
ordiMonteRandTest <- ordi.monte(transMetabData[c(5:601)], ord = "pca", dim = 6, plot = FALSE) #Conduct monte carlo randomization test using 1000 random permutations of the input data.
ordiMonteRandTest

#Will move forward with PC1-2
```

## Plot PCA

```{bash}
mkdir figures
```

```{r}
plotColors <- c(brewer.pal(9, "Reds")[7],
                brewer.pal(9, "Greys")[7],
                brewer.pal(9, "Blues")[7]) #Create color scheme
```

### All metabolites

```{r}
pcaPlot1 <- autoplot(scaled.pca, data = transMetabData, x = 1, y = 2,
                     size = 3, alpha = 0.8, colour = "treatment", shape = "treatment", 
                     frame = TRUE, frame.colour = "treatment", loadings = FALSE) +
  scale_color_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                     name = "Temperature (ºC)") +
  scale_fill_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                    name = "Temperature (ºC)") +
  scale_shape_manual(values = c(15, 19, 17),
                     name = "Temperature (ºC)") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Use autoplot to plot the prcomp object. Color points and confidence ellipses by treatment, and have different shapes for each treatment Do not include loadings. Manually define color, fill, and shapes.
pcaPlot1
ggsave("figures/all-data-PCA-treatment.pdf", height = 8.5, width = 11)
```

```{r}
pcaPlot2 <- autoplot(scaled.pca, data = transMetabData, x = 1, y = 2,
                     size = 5, alpha = 0.8, colour = "day", shape = "day",
                     frame = TRUE, frame.colour = "day", loadings = FALSE) +
  scale_color_manual(values = c("black", "purple"),
                     name = "Day") +
  scale_fill_manual(values = c("black", "purple"),
                    name = "Day") +
  scale_shape_manual(values = c(20, 18),
                     name = "Day") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Same as above but color by day and not treatment
pcaPlot2
ggsave("figures/all-data-PCA-day.pdf", height = 8.5, width = 11)
```

```{r}
pcaPlot3 <- autoplot(scaled.pca, data = transMetabData, x = 1, y = 2,
                     size = 4, alpha = 0.8, colour = "treatment", shape = "day", 
                     frame = TRUE, frame.colour = "treatment", loadings = FALSE) +
  scale_color_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                     name = "Temperature (ºC)") +
  scale_fill_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                    name = "Temperature (ºC)") +
  scale_shape_manual(values = c(20, 18),
                     name = "Day") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Use autoplot to plot the prcomp object. Color points and confidence ellipses by treatment, and have different shapes for each day. Do not include loadings. Manually define color, fill, and shapes.
pcaPlot3
ggsave("figures/all-data-PCA-day-treatment.pdf", height = 8.5, width = 11)
```

Overall, it seems like metabolite profiles are segregating by treatment, with the 30ºC profiles more segregated from the 5ºC and 13ºC profiles. It also seems like metabolite profiles have higher spread over time, potentially due to the impact of prolonged temperature exposure on physiology.

### Identified metabolites

I'm going to make a very similar PCA to the one above, but only using metabolites identified by the sequencer.

```{r}
scaled.pca.id <- prcomp(transMetabData[c(4:155)], scale = TRUE, center = TRUE) #Use prcomp to perform a centered and scaled PCA calculation
summary(scaled.pca.id) #Standard deviations for each PC
```

```{r}
pcaPlot4 <- autoplot(scaled.pca.id, data = transMetabData, x = 1, y = 2,
                     size = 4, alpha = 0.8, colour = "treatment", shape = "day", 
                     frame = TRUE, frame.colour = "treatment", loadings = FALSE) +
  scale_color_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                     name = "Temperature (ºC)") +
  scale_fill_manual(values = c(plotColors[3], plotColors[2], plotColors[1]),
                    name = "Temperature (ºC)") +
  scale_shape_manual(values = c(20, 18),
                     name = "Day") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Use autoplot to plot the prcomp object. Color points and confidence ellipses by treatment, and have different shapes for each day. Do not include loadings. Manually define color, fill, and shapes.
pcaPlot4
ggsave("figures/known-metabolites-PCA-day-treatment.pdf", height = 8.5, width = 11)
```

## Conduct PERMANOVA

I'll use a global permutational multivariate analysis of variance (PERMANOVA) to determine if treatment and day had a significant influence on metabolite profiles. The significant effects from the PCA will be used in the downstream PLS-DA to interrogate trends.

### All metabolites

```{r}
permanova.metab <- adonis2(scale(transMetabData[c(5:601)]) ~ treatment*day, data = transMetabData, method = 'eu') #Conduct global PERMANOVA to assess significance of trends in PCA. Scale metabolomics data and assess influence of treatment, day, and treatment x day on metabolite profiles
permanova.metab #Significant influence of all factors
```

```{r}
broom::tidy(permanova.metab) %>%
  write.csv(., "all-data-PERMANOVA-results.csv", quote = FALSE) #Save PERMANOVA output
```

### Identified metabolites

I'm going to repeat the same analysis, but only look at trends for metabolites identified by the West Coast Metabolomics Center.

```{r}
permanova.metabid <- adonis2(scale(transMetabData[c(5:156)]) ~ treatment*day, data = transMetabData, method = 'eu') #Conduct global PERMANOVA to assess significance of trends in PCA. Scale metabolomics data and assess influence of treatment, day, and treatment x day on metabolite profiles
permanova.metabid #Significant influence of all factors
```

```{r}
broom::tidy(permanova.metab) %>%
  write.csv(., "known-metabolites-PERMANOVA-results.csv", quote = FALSE) #Save PERMANOVA output
```

The fact that all three explanatory variables are significant means that the inclusion of unidentified metabolites doesn't drastically influence the results.

# PLSDA for all metabolites

The next step is for me to conduct a PLS-DA analysis using the `mixOmics` package. This is a more robust way to analyze differences between treatments and is common in many metabolomics studies. Since both temperature and day were significant in the PCA, I'll use both of those factors in the PLSDA.

## Temperature only

I'm still going to run the PLS-DA with temperature only because I suspect the plot will look cleaner this way.

```{r}
X <- log(transMetabData[c(5:601)]) #Assign only metabolite data to the X dataframe after log transformation.
Y <- as.factor(transMetabData$treatment) #Assign treatment data to the Y dataframe
```

```{r}
treatment.plsda <- plsda(X,Y, ncomp = 2) #ncomp = # treatments - 1
plotIndiv(treatment.plsda)
```

```{r}
#pdf("figures/all-data-PLSDA-treatment.pdf", height = 8.5, width = 11)
plotIndiv(treatment.plsda, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = rev(plotColors), pch = c(15, 17, 19), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC)", 
          title = "PLS-DA by Temperature", X.label = "Component 1: 14% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 6% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
pdf("figures/all-data-cimPlot-treatment.pdf", height = 8.5, width = 11)
cim(treatment.plsda, mapping = "Y", row.names = transMetabData$treatment, xlab = "Metabolites", ylab = "Temperature (ºC)", margins = c(8, 5), row.cex = 0.5) #Create CIM plot with metabolites on the x-axis and treatment on the y-axis. 
dev.off()
```

### Extract VIP

The VIP are the metabolites most important for distinguishing between treatments.

```{r}
treatmentVIP <- as.data.frame(PLSDA.VIP(treatment.plsda)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") #Extract VIP information and save as a dataframe. Convert metabolite rownames to a column. 
head(treatmentVIP) #Confirm changes
```

```{r}
write.csv(treatmentVIP, "all-data-VIP-treatment.csv", quote = FALSE, row.names = FALSE) #Save VIP scores
```

```{r}
treatmentVIP %>%
  filter(VIP >= 1) %>%
  nrow(.) #236 metabolites have VIP > 1
236/596 * 100 #39.6% metabolites VIP > 1
```

```{r}
treatmentVIP %>%
  filter(VIP >= 1) %>%
  arrange(VIP) %>%
  ggplot(aes(x = VIP, y = reorder(metabolite, VIP, sum))) +
  geom_point() +
  xlab("VIP Score") + ylab("Metabolite") +
  theme_classic() + theme(axis.text.y = element_text(size = 5)) #Using only metabolites with VIP > 1, arrange by metabolite name and reorder by cumulative VIP score. Plot points and change x and y axis labels.
ggsave("figures/all-data-VIP.pdf", height = 8.5, width = 11)
```
## Temperature x day

```{r}
X <- log(transMetabData[c(5:601)]) #Assign only metabolite data to the X dataframe after log transformation
Y <- as.factor(transMetabData$treatment_day) #Assign treatment data to the Y dataframe
```

```{r}
treatmentday.plsda <- plsda(X,Y, ncomp = 5) #ncomp = # treatments - 1
plotIndiv(treatmentday.plsda)
```
```{r}
#pdf("figures/all-data-PLSDA-day-treatment-comp12.pdf", height = 8.5, width = 11)
plotIndiv(treatmentday.plsda, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "PLS-DA by Temperature and Day", X.label = "Component 1: 14% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 6% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
#pdf("figures/all-data-PLSDA-day-treatment-comp13.pdf", height = 8.5, width = 11)
plotIndiv(treatmentday.plsda, comp = c(1,3), ind.names = FALSE,
          cex = 3, col = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "PLS-DA by Temperature and Day", X.label = "Component 1: 14% Explained Variance", size.xlabel = 15, Y.label = "Component 3: 11% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
pdf("figures/all-data-cimPlot-day-treatment.pdf", height = 8.5, width = 11)
cim(treatment.plsda, mapping = "Y", row.names = transMetabData$treatment_day, xlab = "Metabolites", ylab = "Temperature (ºC) x Day", margins = c(8, 5), row.cex = 0.5) #Create CIM plot with metabolites on the x-axis and treatment x day on the y-axis. 
dev.off()
```

### Extract VIP

```{r}
treatmentdayVIP <- as.data.frame(PLSDA.VIP(treatmentday.plsda)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") #Extract VIP information and save as a dataframe. Convert metabolite rownames to a column.
head(treatmentdayVIP) #Confirm changes
```

```{r}
write.csv(treatmentdayVIP, "all-data-VIP-day-treatment.csv", quote = FALSE, row.names = FALSE) #Save VIP scores
```

```{r}
treatmentdayVIP %>%
  filter(VIP >= 1) %>%
  nrow(.) #251 metabolites have VIP > 1
251/596 * 100 #42.1% metabolites VIP > 1
```

```{r}
treatmentdayVIP %>%
  filter(VIP >= 1) %>%
  arrange(VIP) %>%
  ggplot(aes(x = VIP, y = reorder(metabolite, VIP, sum))) +
  geom_point() +
  xlab("VIP Score") + ylab("Metabolite") +
  theme_classic() + theme(axis.text.y = element_text(size = 5)) #Using only metabolites with VIP > 1, arrange by metabolite name and reorder by cumulative VIP score. Plot points and change x and y axis labels.
ggsave("figures/all-data-VIP-day-treatment.pdf", height = 8.5, width = 11)
```

# PLSDA for known features

While I can use the PLSDA with all features to discuss larger patterns and maybe glean insight into functions of unknown metabolites, running the model with only known features will allow me to more confidently assess differences in metabolic pathways due to temperature and time. I will run this PLSDA for both temperature and day.

```{r}
X <- log(transMetabData[c(5:156)]) #Assign known metabolite data to the X dataframe after log transformation
Y <- as.factor(transMetabData$treatment_day) #Assign treatment data to the Y dataframe
```

```{r}
treatmentday.known.plsda <- plsda(X,Y, ncomp = 5) #ncomp = # treatments - 1
plotIndiv(treatmentday.known.plsda)
```

```{r}
#pdf("figures/known-metabolites-PLSDA-day-treatment-comp12.pdf", height = 8.5, width = 11)
plotIndiv(treatmentday.known.plsda, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "PLS-DA by Temperature and Day", X.label = "Component 1: 12% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 12% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
#pdf("figures/known-metabolites-PLSDA-day-treatment-comp13.pdf", height = 8.5, width = 11)
plotIndiv(treatmentday.known.plsda, comp = c(1,3), ind.names = FALSE,
          cex = 3, col = c("lightblue", "#2171B5", "grey80", "#525252", "salmon", "#CB181D"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "PLS-DA by Temperature and Day", X.label = "Component 1: 12% Explained Variance", size.xlabel = 15, Y.label = "Component 3: 8% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
pdf("figures/known-metabolites-cimPlot-day-treatment.pdf", height = 8.5, width = 11)
cim(treatmentday.known.plsda, mapping = "Y", row.names = transMetabData$treatment_day, xlab = "Metabolites", ylab = "Temperature (ºC) x Day", margins = c(8, 5), row.cex = 0.5) #Create CIM plot with metabolites on the x-axis and treatment x day on the y-axis. 
dev.off()
```

### Extract VIP

```{r}
treatmentday.known.VIP <- as.data.frame(PLSDA.VIP(treatmentday.known.plsda)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") #Extract VIP information and save as a dataframe. Convert metabolite rownames to a column.
head(treatmentdayVIP) #Confirm changes
```

```{r}
write.csv(treatmentday.known.VIP, "known-metabolites-VIP-day-treatment.csv", quote = FALSE, row.names = FALSE) #Save VIP scores
```

```{r}
treatmentday.known.VIP %>%
  filter(VIP >= 1) %>%
  nrow(.) #73 metabolites have VIP > 1
73/151 * 100 #48.3% metabolites VIP > 1
```

```{r}
treatmentday.known.VIP %>%
  filter(VIP >= 1) %>%
  arrange(VIP) %>%
  ggplot(aes(x = VIP, y = reorder(metabolite, VIP, sum))) +
  geom_point() +
  xlab("VIP Score") + ylab("Metabolite") +
  theme_classic() + theme(axis.text.y = element_text(size = 8)) #Using only metabolites with VIP > 1, arrange by metabolite name and reorder by cumulative VIP score. Plot points and change x and y axis labels.
ggsave("figures/known-metabolites-VIP-day-treatment.pdf", height = 8.5, width = 11)
```

## Pairwise tests for VIP metabolites

We now know which metabolites are most important for separating days and treatments. However, we do not know specifically which VIP distinguish between which treatment x day contrasts. I will use pairwise t-tests to understand 

### Treatment differences at day 3

#### 13_3 vs. 30_3

```{r}
list <- c("13_3", "30_3") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13v30_day3 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13v30_day3 <- as.data.frame(PLSDA.VIP(known.plsda_13v30_day3)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
```

```{r}
clean_13v30_day3 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13v30_day3 <- cbind(clean_13v30_day3[, 1:4], 
                               log(clean_13v30_day3[, names(clean_13v30_day3) %in% VIP_13v30_day3$metabolite])) %>%
  pivot_longer(., cols = 5:63, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13v30_day3 #Confirm changes
```

```{r}
t.test_13v30_day3 <-do(VIP_select_13v30_day3, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                          alternative = "two.sided",
                                                          mu = 0,
                                                          paired = FALSE,
                                                          var.equal = FALSE,
                                                          conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13v30_day3$p.adj <- p.adjust(t.test_13v30_day3$p.value, method = c("fdr"), n = length(VIP_13v30_day3$metabolite)) #Adjust p value for the number of comparisons
t.test_13v30_day3
```

```{r}
t.test_13v30_day3 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #0 significantly different metabolites
```

#### 13_3 vs. 5_3

```{r}
list <- c("13_3", "5_3") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13v5_day3 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13v5_day3 <- as.data.frame(PLSDA.VIP(known.plsda_13v5_day3)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_13v5_day3
```

```{r}
clean_13v5_day3 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13v5_day3 <- cbind(clean_13v5_day3[, 1:4], 
                              log(clean_13v5_day3[, names(clean_13v5_day3) %in% VIP_13v5_day3$metabolite])) %>%
  pivot_longer(., cols = 5:66, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13v5_day3 #Confirm changes
```

```{r}
t.test_13v5_day3 <-do(VIP_select_13v5_day3, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                        alternative = "two.sided",
                                                        mu = 0,
                                                        paired = FALSE,
                                                        var.equal = FALSE,
                                                        conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13v5_day3$p.adj <- p.adjust(t.test_13v5_day3$p.value, method = c("fdr"), n = length(VIP_13v5_day3$metabolite)) #Adjust p value for the number of comparisons
t.test_13v5_day3
```

```{r}
t.test_13v5_day3 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #0 significantly different metabolites
```

### Treatment differences at day 22

#### 13_22 vs. 30_22

```{r}
list <- c("13_22", "30_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13v30_day22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13v30_day22 <- as.data.frame(PLSDA.VIP(known.plsda_13v30_day22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_13v30_day22
```

```{r}
clean_13v30_day22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13v30_day22 <- cbind(clean_13v30_day22[, 1:4], 
                                log(clean_13v30_day22[, names(clean_13v30_day22) %in% VIP_13v30_day22$metabolite])) %>%
  pivot_longer(., cols = 5:55, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13v30_day22 #Confirm changes
```

```{r}
t.test_13v30_day22 <-do(VIP_select_13v30_day22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                            alternative = "two.sided",
                                                            mu = 0,
                                                            paired = FALSE,
                                                            var.equal = FALSE,
                                                            conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13v30_day22$p.adj <- p.adjust(t.test_13v30_day22$p.value, method = c("fdr"), n = length(VIP_13v30_day22$metabolite)) #Adjust p value for the number of comparisons
t.test_13v30_day22
```

```{r}
t.test_13v30_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #29 significantly different metabolites
t.test_13v30_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 > estimate2) %>%
  nrow(.) #16 metabolites higher in 13ºC
t.test_13v30_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 < estimate2) %>%
  nrow(.) #13 metabolites higher in 30ºC
```

```{r}
t.test_13v30_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  left_join(., VIP_13v30_day22, by = "metabolite") %>%
  mutate(., direction = case_when(estimate > 1 ~ "13",
                                  estimate < 1 ~ "30")) %>%
  mutate(., score = case_when(estimate > 1 ~ VIP,
                              estimate < 1 ~ -VIP)) %>%
  arrange(score) %>%
  ggplot(aes(x = score, y = reorder(metabolite, score, sum))) +
  geom_bar(aes(fill = direction), stat = 'identity') +
  xlab("VIP Score") + ylab("Metabolite") +
  scale_x_continuous(limits = c(-2, 2), breaks = seq(-2, 2, 1)) +
  scale_fill_manual(values = c(plotColors[2], plotColors[1]), 
                    name = "Temperature (ºC)",
                    breaks = c("13", "30"),
                    labels = c("13", "30")) +
  theme_classic(base_size = 15) + theme() #Take t-test results and filter out significant metabolites. Create two new columns using estimate values: one for the direction of increase, and another for positive or negative VIP. Arrange by metabolite name and reorder by cumulative VIP score. Plot bars and change x and y axis labels. Add scale information.
ggsave("figures/significant-VIP-13v30-day22.pdf", height = 8.5, width = 11)
```

#### 13_22 vs. 5_22

```{r}
list <- c("13_22", "5_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13v5_day22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13v5_day22 <- as.data.frame(PLSDA.VIP(known.plsda_13v5_day22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_13v5_day22
```

```{r}
clean_13v5_day22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13v5_day22 <- cbind(clean_13v5_day22[, 1:4], 
                               log(clean_13v5_day22[, names(clean_13v5_day22) %in% VIP_13v5_day22$metabolite])) %>%
  pivot_longer(., cols = 5:46, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13v5_day22 #Confirm changes
```

```{r}
t.test_13v5_day22 <-do(VIP_select_13v5_day22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                          alternative = "two.sided",
                                                          mu = 0,
                                                          paired = FALSE,
                                                          var.equal = FALSE,
                                                          conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13v5_day22$p.adj <- p.adjust(t.test_13v5_day22$p.value, method = c("fdr"), n = length(VIP_13v5_day22$metabolite)) #Adjust p value for the number of comparisons
t.test_13v5_day22
```

```{r}
t.test_13v5_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #31 significantly different metabolites
t.test_13v5_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 > estimate2) %>%
  nrow(.) #29 metabolites higher in 13ºC
t.test_13v5_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 < estimate2) %>%
  nrow(.) #2 metabolites higher in 30ºC
```

```{r}
t.test_13v5_day22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  left_join(., VIP_13v5_day22, by = "metabolite") %>%
  mutate(., direction = case_when(estimate > 1 ~ "13",
                                  estimate < 1 ~ "5")) %>%
  mutate(., score = case_when(estimate > 1 ~ VIP,
                              estimate < 1 ~ -VIP)) %>%
  arrange(score) %>%
  ggplot(aes(x = score, y = reorder(metabolite, score, sum))) +
  geom_bar(aes(fill = direction), stat = 'identity') +
  xlab("VIP Score") + ylab("Metabolite") +
  scale_x_continuous(limits = c(-2.5, 2.5), breaks = seq(-2, 2, 1)) +
  scale_fill_manual(values = c(plotColors[2], plotColors[3]), 
                    name = "Temperature (ºC)",
                    breaks = c("13", "5"),
                    labels = c("13", "5")) +
  theme_classic(base_size = 15) + theme() #Take t-test results and filter out significant metabolites. Create two new columns using estimate values: one for the direction of increase, and another for positive or negative VIP. Arrange by metabolite name and reorder by cumulative VIP score. Plot bars and change x and y axis labels. Add scale information.
ggsave("figures/significant-VIP-13v5-day22.pdf", height = 8.5, width = 11)
```

### Day differences for each treatment

#### 5_3 vs. 5_22

```{r}
list <- c("5_3", "5_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_5_day3v22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_5_day3v22 <- as.data.frame(PLSDA.VIP(known.plsda_5_day3v22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_5_day3v22
```

```{r}
clean_5_day3v22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_5_day3v22 <- cbind(clean_5_day3v22[, 1:4], 
                              log(clean_5_day3v22[, names(clean_5_day3v22) %in% VIP_5_day3v22$metabolite])) %>%
  pivot_longer(., cols = 5:55, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_5_day3v22 #Confirm changes
```

```{r}
t.test_5_day3v22 <-do(VIP_select_5_day3v22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                        alternative = "two.sided",
                                                        mu = 0,
                                                        paired = FALSE,
                                                        var.equal = FALSE,
                                                        conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_5_day3v22$p.adj <- p.adjust(t.test_5_day3v22$p.value, method = c("fdr"), n = length(VIP_5_day3v22$metabolite)) #Adjust p value for the number of comparisons
t.test_5_day3v22
```

```{r}
t.test_5_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #6 significantly different metabolites
t.test_5_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 > estimate2) %>%
  nrow(.) #0 metabolites higher in day 22
t.test_5_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 < estimate2) %>%
  nrow(.) #6 metabolites higher in day 3
```

```{r}
t.test_5_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  left_join(., VIP_5_day3v22, by = "metabolite") %>%
  mutate(., direction = case_when(estimate > 1 ~ "22",
                                  estimate < 1 ~ "3")) %>%
  mutate(., score = case_when(estimate > 1 ~ VIP,
                              estimate < 1 ~ -VIP)) %>%
  arrange(score) %>%
  ggplot(aes(x = score, y = reorder(metabolite, score, sum))) +
  geom_bar(aes(fill = direction), stat = 'identity') +
  xlab("VIP Score") + ylab("Metabolite") +
  scale_x_continuous(limits = c(-2.5, 2.5), breaks = seq(-2, 2, 1)) +
  scale_fill_manual(values = c("black", "purple"), 
                    name = "Day",
                    breaks = c("3", "22"),
                    labels = c("3", "22")) +
  theme_classic(base_size = 15) + theme() #Take t-test results and filter out significant metabolites. Create two new columns using estimate values: one for the direction of increase, and another for positive or negative VIP. Arrange by metabolite name and reorder by cumulative VIP score. Plot bars and change x and y axis labels. Add scale information.
ggsave("figures/significant-VIP-5-day3v22.pdf", height = 8.5, width = 11)
```

#### 13_3 vs. 13_22

```{r}
list <- c("13_3", "13_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_13_day3v22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_13_day3v22 <- as.data.frame(PLSDA.VIP(known.plsda_13_day3v22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_13_day3v22
```

```{r}
clean_13_day3v22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_13_day3v22 <- cbind(clean_13_day3v22[, 1:4], 
                               log(clean_13_day3v22[, names(clean_13_day3v22) %in% VIP_13_day3v22$metabolite])) %>%
  pivot_longer(., cols = 5:61, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_13_day3v22 #Confirm changes
```

```{r}
t.test_13_day3v22 <-do(VIP_select_13_day3v22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                          alternative = "two.sided",
                                                          mu = 0,
                                                          paired = FALSE,
                                                          var.equal = FALSE,
                                                          conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_13_day3v22$p.adj <- p.adjust(t.test_13_day3v22$p.value, method = c("fdr"), n = length(VIP_13_day3v22$metabolite)) #Adjust p value for the number of comparisons
t.test_13_day3v22
```

```{r}
t.test_13_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #0 significantly different metabolites
```

#### 30_3 vs. 30_22

```{r}
list <- c("30_3", "30_22") #Assign treatments to examine
```

```{r}
X <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts
Y <- as.factor(X$treatment_day) #Treatments for Y
X <- X[, 5:156] #Retain data only
```

```{r}
known.plsda_30_day3v22 <- plsda(X, Y, ncomp = 5) #Run PLSDA for desired contrast
VIP_30_day3v22 <- as.data.frame(PLSDA.VIP(known.plsda_30_day3v22)[["tab"]]) %>%
  rownames_to_column(., var = "metabolite") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
VIP_30_day3v22
```

```{r}
clean_30_day3v22 <- transMetabData %>%
  dplyr::filter(., treatment_day %in% list) %>%
  droplevels() #Filter transMetabData for desired contrasts.
VIP_select_30_day3v22 <- cbind(clean_30_day3v22[, 1:4], 
                               log(clean_30_day3v22[, names(clean_30_day3v22) %in% VIP_30_day3v22$metabolite])) %>%
  pivot_longer(., cols = 5:67, values_to = "log_norm_counts", names_to = "metabolite") %>%
  group_by(., metabolite) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by metabolites.
VIP_select_30_day3v22 #Confirm changes
```

```{r}
t.test_30_day3v22 <-do(VIP_select_30_day3v22, tidy(t.test(.$log_norm_counts ~ .$treatment_day,
                                                          alternative = "two.sided",
                                                          mu = 0,
                                                          paired = FALSE,
                                                          var.equal = FALSE,
                                                          conf.level = 0.95
))) #Looped t-test for all metabolites with VIP > 1
t.test_30_day3v22$p.adj <- p.adjust(t.test_30_day3v22$p.value, method = c("fdr"), n = length(VIP_30_day3v22$metabolite)) #Adjust p value for the number of comparisons
t.test_30_day3v22
```

```{r}
t.test_30_day3v22 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #0 significantly different metabolites
```

# Validate PLSDA model

It's important to validate the PLSDA model. First, I'll run a permutation test to determine how many components to include.

```{r}
MyPerf.plsda <- perf(treatmentday.known.plsda, validation = "Mfold", folds = 6,  
                     progressBar = TRUE, nrepeat = 50) 

plot(MyPerf.plsda, sd = TRUE) #Overall, increasing the number of components decreases the error rate. There doesn't seem to be an exponential reduction of error rate after 3 components.
```

Next, I'll assess the optimal number of metabolites to keep in the analysis.

```{r}
list.keepX <- c(5:10,  seq(20, 300, 10)) #list.keepX # to output the grid of values tested
X <- log(transMetabData[c(5:156)]) #Assign known metabolite data to the X dataframe after log transformation
Y <- as.factor(transMetabData$treatment_day) #Assign treatment data to the Y dataframe
```

```{r}
tune.splsda.srbct <- tune.splsda(X, Y, ncomp = 5, 
                                 validation = 'Mfold', folds = 6,
                                 measure = "BER", test.keepX = list.keepX, nrepeat = 50) #More extensive classification performance
plot(tune.splsda.srbct) #Plot results
```

```{r}
error <- tune.splsda.srbct$error.rate #Save error rate
ncomp <- tune.splsda.srbct$choice.ncomp$ncomp #Optimal number of components based on t-tests on the error rate
ncomp #5 components! That's how many I have

select.keepX <- tune.splsda.srbct$choice.keepX #Optimal number of variables to select (e.g., number of metabolite features)
select.keepX #sPLSDA should be run with 40 features
```

```{r}
myResult.splsda.final_T <- splsda(X, Y, ncomp = ncomp, keepX = select.keepX) #Use the number of components and meatbolites to keep based on optimization from above  
```

```{r}
#pdf("figures/known-metabolites-sPLSDA-day-treatment-comp12.pdf", height = 8.5, width = 11)
plotIndiv(myResult.splsda.final_T, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c("#525252", "grey80", "#CB181D", "salmon", "#2171B5", "lightblue"), pch = c(12:17), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC) x Day", 
          title = "sPLS-DA by Temperature and Day", X.label = "Component 1: 9% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 6% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2")
#dev.off()
```

# WCNA analysis for known metabolites

Although I have lists of VIP associated with each pairwise comparison, there is one additional step I can take to determine which known metabolites are associated with different treatment x day combinations. I will use a Weighted Correlation Network Analysis (similar to a WGCNA for gene expression) to group metabolites together by abundance patterns, then correlate metabolite modules with treatment and day.

## Data preparation

### Format data

I need to convert my dataframe such that samples are columns and metabolites are rows. I also need to have a dataframe without metadata.

```{r}
head(rawMetabolomicsData)
head(metabolomicsMetadata)
```

```{r}
rowwiseMetabData <- rawMetabolomicsData %>%
  dplyr::rename(., metabolite = BinBase.name) %>%
  dplyr::select(., -c(2:8)) %>%
  column_to_rownames(., var = "metabolite") %>%
  slice(., c(1:152)) %>%
  log(.) #Take the raw metabolomics data, since that dataframe already has samples in columns and metabolites in rows. Rename the metabolite column, get rid of extraneous data, and change the metabolite column to rownames. Keep only data from known metabolites. Log transform the data.
tail(rowwiseMetabData) #Confirm formatting
```

```{r}
rowSums(dplyr::count(rowwiseMetabData)) > 0 #Check that there are no metabolites with 0 counts for all samples. Should return TRUE.  
```

### Data filtering: PoverA and genefilter

*pOverA*: Specifying the minimum count for a proportion of samples for each metabolite. Here, we are using a pOverA of 0.08. This is because we have 69 samples with a minimum of n = 6 samples per treatment x day. Therefore, we will accept metabolites that are present in 6/69 = 0.08 of the samples because we expect different metabolites by temperature and day as demonstrated by PLSDA analysis. We are further setting the minimum value of metabolites to 0.01 (median normalized), such that 8% of the samples must have a non-zero normalized metabolite presence in order for the metabolite to remain in the data set.  

Filter in the package "genefilter". Pre-filtering our dataset to reduce the memory size dataframe, increase the speed of the transformation and testing functions, and improve quality of statistical analysis by removing low-coverage counts. Removed counts could represent outliers in the data and removing these improves sensitivity of statistical tests.

```{r}
filt <- filterfun(pOverA(0.08, 0.01)) #Define the filter
gfilt <- genefilter(rowwiseMetabData, filt) #Create filter for the metabolite data
```

```{r}
keep <- rowwiseMetabData[gfilt,] #Identify metabolites to keep by count filter
n.keep <- rownames(keep) #Identify metabolite lists

rowwiseMetabData_filt <- as.data.frame(rowwiseMetabData[which(rownames(rowwiseMetabData) %in% n.keep),]) #Metabolite count data filtered in PoverA, P percent of the samples have counts over A
```

```{r}
#How many rows do we have before and after filtering?
nrow(rowwiseMetabData) #Before
nrow(rowwiseMetabData_filt) #After
```

All 152 metabolites will be used in downstream analysis.

```{r}
#Checking that all row and column names match. Should return "TRUE"
all(rownames(metabolomicsMetadata$sample_id) %in% colnames(rowwiseMetabData_filt))
all(rownames(metabolomicsMetadata$sample_id) == colnames(rowwiseMetabData_filt)) 
```

### Outlier detection

I will identify outliers visually through a clustering analysis.

```{r}
sampleTree <- hclust(dist(rowwiseMetabData), method = "average") #Perform clustering analysis
```

```{r}
#pdf("figures/metabolite-outliers.pdf", height = 8.5, width = 11)
plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 0.8, cex.axis = 0.8, cex.main = 2) #Plot cluster dendogram
#dev.off()
```

Based on the tree, taurine and sulfuric acid might be outliers.

```{r}
rowwiseMetabData %>% filter(., rownames(.) == "taurine")
rowwiseMetabData %>% filter(., rownames(.) == "sulfuric acid")
```

```{r}
rowwiseMetabData <- t(rowwiseMetabData) %>% as.data.frame(.) #Transpose such that samples are in rows and metabolites are in columns.  
head(rowwiseMetabData) #Confirm changes
```

Construct a new cluster dendogram to visually identify sample outliers.

```{r}
sampleTree <- hclust(dist(rowwiseMetabData), method = "average") #Perform clustering analysis
```

```{r}
#pdf("figures/sample-outliers.pdf", height = 8.5, width = 11)
plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
#dev.off()
```

There don't seem to be any samples that look like outliers (but it's also interesting how there isn't a clear separation of samples by tank or treatment).

## Network construction and consensus module detection

### Choosing a soft-thresholding power: Analysis of a network topology β  

The soft thresholding power (β) is the number to which the co-expression similarity is raised to calculate adjacency. The function `pickSoftThreshold` performs a network topology analysis. The user chooses a set of candidate powers, however the default parameters are suitable values.  

```{r, message=FALSE, warning=FALSE}
allowWGCNAThreads()
powers <- c(c(1:20), seq(from = 12, to=20, by=2)) #Create a string of numbers from 1 through 10, and even numbers from 10 through 20
sft <-pickSoftThreshold(rowwiseMetabData, powerVector = powers, verbose = 5) # Call the network topology analysis function
```

```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# # # Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# # # this line corresponds to using an R^2 cut-off
abline(h=0.85,col="red")
# # # Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

When choosing a soft thresholding power, want to choose the lowest number that reaches the R<sup>2</sup> cutoff. From this data, it appears that the **soft thresholding power is 6**.  

### Identify modules using `blockwiseModules`  

Use `blockwiseModules` to identify modules of metabolites.  

Settings used: 

networkType = "unsigned" 
deepSplit = 2
pamRespectsDendro = F
minModuleSize = 5
maxBlockSize = 4000
reassignThreshold = 0
mergeCutHeight = 0.25

```{r, echo=TRUE, warning=FALSE, message=FALSE}

picked_power = 6
temp_cor <- cor       
cor <- WGCNA::cor # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(rowwiseMetabData,                         # <= input here
                          
                          # == Adjacency Function ==
                          power = picked_power,               # <= power here
                          networkType = "unsigned",
                          
                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,                  
                          maxBlockSize = 4000,
                          
                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,
                          
                          # == TOM == Archive the run results in TOM file (saves time) but it doesn't save a file
                          saveTOMs = F,
                          saveTOMFileBase = "ER",
                          
                          # == Output Options
                          numericLabels = T,
                          verbose = 3)

cor <- temp_cor     # Return cor function to original namespace
```

```{r}
mergedColors = netwk$colors # Identify labels as numbers 
table(mergedColors)
```

Module sizes are as follows: 

0  1  2  3  4  5  6  7  8 
40 22 22 19 15 10 10  8  6 

```{r}
# Plot the dendrogram and the module colors underneath

#pdf("figures/cluster-dendogram-mergedME.pdf")
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
#dev.off()
```

### Relate modules to sample information

``` {r, echo=TRUE, warning=FALSE, message=FALSE}
module_df <- data.frame(
  Metabolite = names(netwk$colors),
  colors = netwk$colors
  #colors = labels2colors(netwk$colors)
)

module_df[1:5,]

write.csv(module_df, "metabolite_modules.csv")

# Get Module Eigengenes per cluster
MEs <- moduleEigengenes(rowwiseMetabData, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs <- orderMEs(MEs)
module_order = names(MEs) %>% gsub("ME","", .)

# Add Sample names
MEs0 <- MEs
MEs0$Sample.ID = row.names(MEs)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-Sample.ID) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=Sample.ID, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-Sample Relationships", y = "Modules", fill="corr")
```

### Relate modules to treatment and day

Prepare trait data. Data has to be numeric, so I will substitute temperatures and days for numeric values. TMake a dataframe that has a column for each treatment or day and a row for samples. Populate a 1 for samples that match each treatment or day and a 0 for samples not matching respective treatments or days This process changes treatments and days from a categorical variable into a binary variable. This will allow for correlations between mean eigengenes and treatment or day.  

```{r}
head(metabolomicsMetadata)
```

```{r}
datTraits <- metabolomicsMetadata %>%
  mutate(., "13ºC at Day 3" = case_when(treatment_day == "13_3" ~ 1,
                                        treatment_day != "13_3" ~ 0)) %>%
  mutate(., "5ºC at Day 3" = case_when(treatment_day == "5_3" ~ 1,
                                        treatment_day != "5_3" ~ 0)) %>%
  mutate(., "30ºC at Day 3" = case_when(treatment_day == "30_3" ~ 1,
                                        treatment_day != "30_3" ~ 0)) %>%
  mutate(., "13ºC at Day 22" = case_when(treatment_day == "13_22" ~ 1,
                                        treatment_day != "13_22" ~ 0)) %>%
  mutate(., "5ºC at Day 22" = case_when(treatment_day == "5_22" ~ 1,
                                        treatment_day != "5_22" ~ 0)) %>%
  mutate(., "30ºC at Day 22" = case_when(treatment_day == "30_22" ~ 1,
                                        treatment_day != "30_22" ~ 0)) %>%
  dplyr::select(., -c(2:4)) #Copy dataframe into datTraits, then use a series of case_when commands to create individual columns for each treatment or day, with 1 indicating that sample is part of the group, and 0 indicating that sample is not part of the group. Remove previous treatment classification columns. 
rownames(datTraits) <- datTraits$crab.ID #Convert crab.ID into rownames.
datTraits <- datTraits %>%
  dplyr::select(., -crab.ID) #Remove the crab.ID column
head(datTraits) #Confirm dataframe creation
```

```{r}
#Define numbers of metabolites and samples and view 
nMetabolites <- ncol(rowwiseMetabData)
nSamples <- nrow(rowwiseMetabData)

nMetabolites
nSamples
```

We have 152 metabolites and 69 samples.   

Next correlate the trait matrix (treatment, day) with eigengenes (modules).  

```{r}
moduleTraitCor <- cor(MEs, datTraits, use = "p") #Correlations of traits with eigengenes
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples) #Get p-values for correlations
head(moduleTraitCor %>% as.data.frame())
head(moduleTraitPvalue %>% as.data.frame())
```

```{r}
moduleTraitTree <- hclust(dist(t(moduleTraitCor)), method = "average") #Create cluster dendogram for module-trait correlations
```

```{r}
pdf(file = "figures/module-trait-cluster-dendogram.pdf", height = 8.5, width = 11)
plot(moduleTraitTree) #Plot cluster dendogram
dev.off()
```

```{r}
# Correlations of metabolites with eigengenes. Calculate correlations between ME's and groups 
moduleGeneCor <- cor(MEs, rowwiseMetabData) #Correlate eigengenes with metabolites
moduleGenePvalue <- corPvalueStudent(moduleGeneCor, nSamples) #Calculate p-values for metabolite-eigengene correlations
head(moduleGeneCor %>% as.data.frame)
head(moduleGenePvalue %>% as.data.frame(.))
```

## Plot module-trait associations

```{r, echo=TRUE, warning=FALSE, message=FALSE}
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",signif(moduleTraitPvalue, 1), ")", sep = "") #Create a matrix with the module-trait correlation and p-values
dim(textMatrix) <- dim(moduleTraitCor) #Ensure this matrix has the appropriate dimensions
head(textMatrix) #Confirm matrix creation
```

```{r}
pdf("figures/module-trait-relationships.pdf", height = 8.5, width = 11)
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y = 1.5, cex.lab.x = 1.5, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 1, zlim = c(-1,1), main = paste("Module-trait relationships"), cex.main = 2) #Use the textMatrix to create a heatmap with correlations between modules and the various treatments.
dev.off()
```

```{r, echo=TRUE, warning=FALSE, message=FALSE}
heatmappval <- signif(moduleTraitPvalue, 1) #Create list of pvalues for eigengene correlation with specific traits

row_dend <- dendsort(hclust(dist(moduleTraitCor))) #Create dendograms for rows
col_dend <- dendsort(hclust(dist(t(moduleTraitCor)))) #Create dendograms for columns

trait_order <- c("5ºC at Day 3", "13ºC at Day 3", "30ºC at Day 3", "5ºC at Day 22", "13ºC at Day 22", "30ºC at Day 22") #Order of traits for heatmap
```

```{r}
pdf(file = "figures/module-trait-relationship-heatmap.pdf", height = 8.5, width = 8.5)
ht <- Heatmap(moduleTraitCor, name = "Eigengene", column_title = "Module-Group Eigengene Correlation",
              col = blueWhiteRed(50), 
              row_names_side = "left", 
              row_dend_side = "left",
              width = unit(5, "in"), 
              height = unit(4.5, "in"), 
              column_dend_reorder = TRUE, 
              cluster_columns = col_dend,
              row_dend_reorder = FALSE,  
              #column_split = 3, 
              #row_split = 3, 
              #column_dend_height = unit(.5, "in"),
              cluster_rows = row_dend, 
              #column_order = trait_order, 
              #row_gap = unit(2.5, "mm"), 
              border = TRUE,
              cell_fun = function(j, i, x, y, w, h, col) {
                if(heatmappval[i, j] < 0.05) {
                  grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
                }
                else {
                  grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
                }},
              column_names_rot = 45,
              column_names_gp =  gpar(fontsize = 12, border = FALSE),
              column_title_gp = gpar(fontsize = 20),
              row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE)) #Create a heatmap object
draw(ht) #Draw heatmap
dev.off()
```

## Plot mean eigengene values for each module  

## Pathway analysis    











