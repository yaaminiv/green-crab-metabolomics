---
title: "06-lipidomics-analysis"
author: "Yaamini Venkataraman"
date: '2023-12-30'
output: html_document
---

In this script, I will analyze lipidomics data from the West Coast Metabolomics Center (UC Davis). I will conduct an initial assessment of the data (PCA and PLS-DA), understand important lipids and pathways (VIP analysis and WGCNA), and prepare for additional network analysis through MetaboAnalyst. This workflow and script is modified from [Huffmyer et al. (2023)](https://www.biorxiv.org/content/10.1101/2023.03.20.533475v2.full) and [Trigg et al. (2019)](http://dx.doi.org/10.1038/s41598-019-46947-6).

# Set up R Markdown document

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath("../output/06-lipidomics-analysis/")) #Set root directory
```

```{r}
getwd()
```

# Install packages

```{r packages, warning = FALSE, message = FALSE}
# if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse')
# if ("vegan" %in% rownames(installed.packages()) == 'FALSE') install.packages('vegan')
# if ("ggfortify" %in% rownames(installed.packages()) == 'FALSE') install.packages('ggfortify')
# if (!requireNamespace("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# if ("mixOmics" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("mixOmics")
# if ("RVAideMemoire" %in% rownames(installed.packages()) == 'FALSE') install.packages('RVAideMemoire')
# if ("broom" %in% rownames(installed.packages()) == 'FALSE') install.packages('broom')
# if ("RColorBrewer" %in% rownames(installed.packages()) == 'FALSE') install.packages('RColorBrewer')
# if ("pheatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('pheatmap')
# if ("genefilter" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("genefilter")
# if ("WGCNA" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('WGCNA')
# if ("dendsort" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('dendsort')
# if ("ComplexHeatmap" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ComplexHeatmap')
# if ("svglite" %in% rownames(installed.packages()) == 'FALSE') install.packages("svglite")
require(tidyverse)
require(vegan)
require(ggfortify)
require(mixOmics)
require(RVAideMemoire)
require(broom)
require(RColorBrewer)
require(pheatmap)
require(genefilter)
require(WGCNA)
require(dendsort)
require(ComplexHeatmap)
require(svglite)
```

```{r}
source("../../code/biostats.R") #Source multivariate analysis functions
```

```{r}
sessionInfo()
```

# Pre-processsing

The file of lipid abundances I got from the West Coast Metabolomics Center did not have common names and PubMed CID for all lipids. I did, however, have InChiKeys for all compounds. I manually acquired common name and CID for InChiKeys using the [Chemical Translation Service](http://cts.fiehnlab.ucdavis.edu/batch) and [PubMed](https://pubchem.ncbi.nlm.nih.gov/).

# Import data

```{r}
rawLipidomicsData <- read.csv("../../data/raw_lipidomics_data.csv", header = TRUE) %>% 
  dplyr::rename_with(~stringr::str_replace_all(., "X", "")) #Import data. Remove the "X" prefix for crab IDs.
rawLipidomicsData[c(8:76)] <- rawLipidomicsData[c(8:76)] %>% mutate_if(is.character, as.numeric) #Convert data columns to numeric
head(rawLipidomicsData) #Confirm import
```


```{r}
inChiKeyNamePubmed <- read.csv("../../data/cts-inchikey-name-pubmed.csv", header = TRUE, na.strings = c("", "NA")) %>%
  dplyr::rename(., INCHIKEY = InChIKey) %>%
  filter(., is.na(Chemical.Name) == FALSE) %>% 
  unique(.) #Import table with translations from InChiKeys. Set "" or NA as NA, then remove rows without any chemical name. Remove potential duplicate entries.
nrow(inChiKeyNamePubmed) #391 unique lipids with chemical names and PubMed CID
head(inChiKeyNamePubmed) #Confirm file import
```

```{r}
lipidomicsMetadata <- read.csv("../../data/metabolomics_metadata.csv", header = FALSE, strip.white = TRUE) %>% 
  dplyr::rename_with(~stringr::str_replace_all(., "V", "")) %>%
  t(.) %>% as.data.frame(.) %>% 
  purrr::set_names(as.character(dplyr::slice(., 1))) %>%
  dplyr::slice(., -1) %>% 
  mutate(., unite(., "treatment", treatment:day, sep = "_")) %>%
  mutate(., treatment = gsub(x = treatment, pattern = "_  3", replacement = "_3")) %>%
  mutate(., treatment = gsub(x = treatment, pattern = "_ 22", replacement = "_22")) %>%
  mutate(., treatment = gsub(x = treatment, pattern = " 13_", replacement = "13_")) %>%
  mutate(., treatment = gsub(x = treatment, pattern = " 30_", replacement = "30_")) %>%
  mutate(., treatment = gsub(x = treatment, pattern = "  5_", replacement = "5_")) %>% 
  mutate(., treatment = gsub(x = treatment, pattern = " ", replacement = "")) %>%
  mutate(., day = gsub(x = day, pattern = " ", replacement = "")) #Import metadata. Do not include any header information. Remove "V" from column names. Transform so crab.ID, treatment, and day are all columns. Set the first row in the dataframe as column names, then remove that row. Transform characters in each column for correct formatting
tail(lipidomicsMetadata) #Confirm import
```

# Format data

Before analyzing the data, I will transform the data and match with treatment metadata. The West Coast Metabolomics Center has already normalized data, but I noticed I had some duplicate entries. Here's the information from the center:

> I have confirmed with our staff that in this case, the entries are the same lipid in different adduct forms. Normally our staff would combine these into one annotation, but occasionally adducts slip through our curation procedures unnoticed. You can simply take the sum of the values and combine the adducts into one annotation.

```{r}
transLipidData <- rawLipidomicsData %>%
  mutate(lipid = case_when(lipid == "" ~ identifier,
                           lipid != "" ~ lipid)) %>%
  dplyr::select(-c(identifier, Ion.species:ESI.mode)) %>%
  group_by(lipid) %>%
  summarise(across(where(is.numeric), ~ sum(.x, na.rm = TRUE))) %>%
  t(.) %>% as.data.frame(.) %>%
  purrr::set_names(as.character(dplyr::slice(., 1))) %>%
  dplyr::slice(., -1) %>%
  rownames_to_column(., var = "crab.ID") %>%
  left_join(lipidomicsMetadata, ., by = "crab.ID") #Take raw data and modify lipid column such that if there is no lipid name, the identifier is used instead. Add lipid abundance across numeric columns to deal with any duplicate entries (same lipid detected in different adduct forms). Transpose data, convert the first row (lipid) to column names, and remove this row. Convert rownames to crab ID column. Join with lipidomics metadata. 
transLipidData[, c(5:2407)] <- transLipidData[, c(5:2407)] %>% mutate_if(is.character, as.numeric) #Convert data columns to numeric
head(transLipidData) #Confirm changes
```

```{r}
lipidIdentifiers <- rawLipidomicsData %>%
  right_join(inChiKeyNamePubmed, ., by = "INCHIKEY") %>%
  arrange(., "PubChem.ID") %>% 
  dplyr::select(4:5, 3:1) #Save dataframe with all possible identifiers for downstream analysis
head(lipidIdentifiers)
```

# Initial data investigation with PCA

```{bash}
mkdir PCA
mkdir PCA/figures
```

```{r}
scaled.pca <- prcomp(transLipidData[c(5:2407)] %>%
                       log() %>%
                       mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
                       replace(is.na(.), 0), 
                     scale = FALSE, center = TRUE) #Use prcomp to perform a centered and scaled PCA calculation. Replace all -Inf with NA, and then with 0 in the dataframe and log transform prior to performing the PCA calculation
summary(scaled.pca) #Standard deviations for each PC
```

```{r PCA interpretation}
pca.eigenval(scaled.pca) #Eigenvalues greater than the broken-stick expectation are considered to explain a statistically significance proportion of the variance in the original dataset.
ordiMonteRandTest <- ordi.monte((transLipidData[c(5:2407)] %>%
                                   log() %>%
                                   mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
                                   replace(is.na(.), 0)), 
                                ord = "pca", dim = 6, plot = FALSE) #Conduct monte carlo randomization test using 1000 random permutations of the input data.
ordiMonteRandTest

#Will move forward with PC1-2
```

## Plot PCA

```{r}
plotColors <- c(brewer.pal(9, "Reds")[7],
                brewer.pal(9, "Greys")[7],
                brewer.pal(9, "Blues")[7]) #Create color scheme
```

```{r}
pcaPlot1 <- autoplot(scaled.pca, data = transLipidData, x = 1, y = 2,
                     size = 3, alpha = 0.8, colour = "treatment", shape = "treatment", 
                     frame = TRUE, frame.colour = "treatment", loadings = FALSE) +
  scale_color_manual(values = c(plotColors[2], plotColors[1], plotColors[3]),
                     name = "Temperature (ºC)") +
  scale_fill_manual(values = c(plotColors[2], plotColors[1], plotColors[3]),
                    name = "Temperature (ºC)") +
  scale_shape_manual(values = c(15, 19, 17),
                     name = "Temperature (ºC)") +
  scale_size(guide = "none") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Use autoplot to plot the prcomp object. Color points and confidence ellipses by treatment, and have different shapes for each treatment Do not include loadings. Manually define color, fill, and shapes.
pcaPlot1
ggsave("PCA/figures/all-data-PCA-treatment.pdf", height = 8.5, width = 11)
```

```{r}
pcaPlot2 <- autoplot(scaled.pca, data = transLipidData, x = 1, y = 2,
                     size = 5, alpha = 0.8, colour = "day", shape = "day",
                     frame = TRUE, frame.colour = "day", loadings = FALSE) +
  scale_color_manual(values = c("black", "purple"),
                     name = "Day") +
  scale_fill_manual(values = c("black", "purple"),
                    name = "Day") +
  scale_shape_manual(values = c(20, 18),
                     name = "Day") +
  scale_size(guide = "none") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Same as above but color by day and not treatment
pcaPlot2
ggsave("PCA/figures/all-data-PCA-day.pdf", height = 8.5, width = 11)
```

```{r}
pcaPlot3 <- autoplot(scaled.pca, data = transLipidData, x = 1, y = 2,
                     size = 4, alpha = 0.8, colour = "treatment", shape = "day", 
                     frame = TRUE, frame.colour = "treatment", loadings = FALSE) +
  scale_color_manual(values = c(plotColors[2], plotColors[1], plotColors[3]),
                     name = "Temperature (ºC)") +
  scale_fill_manual(values = c(plotColors[2], plotColors[1], plotColors[3]),
                    name = "Temperature (ºC)") +
  scale_shape_manual(values = c(20, 18),
                     name = "Day") +
  scale_size(guide = "none") +
  theme_classic(base_size = 15) + theme(legend.position = "right",
                                        plot.background = element_blank()) #Use autoplot to plot the prcomp object. Color points and confidence ellipses by treatment, and have different shapes for each day. Do not include loadings. Manually define color, fill, and shapes.
pcaPlot3
ggsave("PCA/figures/all-data-PCA-day-treatment.pdf", height = 8.5, width = 11)
```

Overall, it seems like lipid profiles are segregating by treatment, with the 30ºC profiles more segregated from the 5ºC and 13ºC profiles.

## Conduct PERMANOVA

I'll use a global permutational multivariate analysis of variance (PERMANOVA) to determine if treatment and day had a significant influence on metabolite profiles. The significant effects from the PCA will be used in the downstream PLS-DA to interrogate trends.

```{r}
permanova.lipid <- adonis2(scale((transLipidData[c(5:2407)] %>%
                                    log() %>%
                                    mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
                                    replace(is.na(.), 0))) ~ treatment*day, data = transLipidData, method = 'eu') #Conduct global PERMANOVA to assess significance of trends in PCA. Scale lipidomics data and assess influence of treatment, day, and treatment x day on metabolite profiles
permanova.lipid #Significant influence of all factors
```

```{r}
broom::tidy(permanova.lipid) %>%
  write.csv(., "PCA/all-data-PERMANOVA-results.csv", quote = FALSE) #Save PERMANOVA output
```

# PLSDA for all lipids

The next step is for me to conduct a PLS-DA analysis using the `mixOmics` package. This is a more robust way to analyze differences between treatments. Since only temperature was significant, I'll only include that factor. However, I'll still run the PLSDA with treatment and day just to see what it look

```{bash}
mkdir PLSDA
mkdir PLSDA/figures
```

## Temperature only

I'm still going to run the PLS-DA with temperature only because I suspect the plot will look cleaner this way.

```{r}
X <- (transLipidData[c(5:2407)] %>%
        log() %>%
        mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
        replace(is.na(.), 0)) #Assign only metabolite data to the X dataframe after log transformation.
Y <- as.factor(transLipidData$treatment) #Assign treatment data to the Y dataframe
```

```{r}
treatment.plsda <- plsda(X,Y, ncomp = 2) #ncomp = # treatments - 1
plotIndiv(treatment.plsda)
```

```{r}
#pdf("PLSDA/figures/all-data-PLSDA-treatment.pdf", height = 8.5, width = 11)
plotIndiv(treatment.plsda, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c(plotColors[2], plotColors[1], plotColors[3]), pch = c(19, 17, 15), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC)", 
          title = "PLS-DA by Temperature", X.label = "Component 1: 30% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 10% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
pdf("PLSDA/figures/all-data-cimPlot-treatment.pdf", height = 8.5, width = 11)
cim(treatment.plsda, mapping = "Y", row.names = transLipidData$treatment, xlab = "Unique Lipid ID", ylab = "Temperature (ºC)", margins = c(8, 5), row.cex = 0.5) #Create CIM plot with lipids on the x-axis and treatment on the y-axis. 
dev.off()
```

### Extract VIP

The VIP are the lipids most important for distinguishing between treatments.

```{r}
treatmentVIP <- as.data.frame(PLSDA.VIP(treatment.plsda)[["tab"]]) %>%
  rownames_to_column(., var = "lipid") #Extract VIP information and save as a dataframe. Convert metabolite rownames to a column. 
head(treatmentVIP) #Confirm changes
```

```{r}
write.csv(treatmentVIP, "PLSDA/all-data-VIP-treatment.csv", quote = FALSE, row.names = FALSE) #Save VIP scores
```

```{r}
treatmentVIP %>%
  filter(VIP >= 1) %>%
  nrow(.) #1020 lipids have VIP > 1
1020/2402 * 100 #42.5% lipids VIP > 1
```

```{r}
treatmentVIP %>%
  filter(VIP >= 1) %>%
  arrange(VIP) %>%
  ggplot(aes(x = VIP, y = reorder(lipid, VIP, sum))) +
  geom_point() +
  xlab("VIP Score") + ylab("Lipid") +
  theme_classic() + theme(axis.text.y = element_text(size = 5)) #Using only lipids with VIP > 1, arrange by metabolite name and reorder by cumulative VIP score. Plot points and change x and y axis labels.
ggsave("PLSDA/figures/all-data-VIP.pdf", height = 8.5, width = 11)
```

# PLSDA for known features

While I can use the PLSDA with all features to discuss larger patterns and maybe glean insight into functions of unknown lipid classes, running the model with only known features will allow me to more confidently assess differences in lipids due to temperature and time. I am defining "known features" as those with a PubMed.CID.

I will run this PLSDA for temperature only, since that was the only factor significant in the perMANOVA.

```{r}
knownTransLipidData <- transLipidData %>%
  dplyr::select(1:4, which(colnames(transLipidData) %in% lipidIdentifiers$lipid[1:418])) #Take transposed lipid data and select columns associated with known lipids.
head(knownTransLipidData)
```

```{r}
X <- log(knownTransLipidData[-c(1:4)]) #Assign known metabolite data to the X dataframe after log transformation
Y <- as.factor(knownTransLipidData$treatment) #Assign treatment data to the Y dataframe
```

```{r}
treatment.known.plsda <- plsda(X,Y, ncomp = 3) #ncomp = # treatments - 1
plotIndiv(treatment.known.plsda, comp = c(1,2))
plotIndiv(treatment.known.plsda, comp = c(1,3))
```

```{r}
#pdf("PLSDA/figures/known-lipids-PLSDA-treatment-comp12.pdf", height = 8.5, width = 11)
plotIndiv(treatment.known.plsda, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c(plotColors[2], plotColors[1], plotColors[3]), pch = c(19, 17, 15), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC)", 
          title = "PLS-DA by Temperature", X.label = "Component 1: 27% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 19% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```
```{r}
#svg("PLSDA/figures/known-lipids-PLSDA-treatment-comp12.svg", height = 8.5, width = 11)
plotIndiv(treatment.known.plsda, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c(plotColors[2], plotColors[1], plotColors[3]), pch = 19, point.lwd = 0.7,
          ellipse = FALSE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC)", legend.position = "bottom",
          title = "PLS-DA by Temperature", X.label = "Component 1: 27% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 19% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
#pdf("PLSDA/figures/known-lipids-PLSDA-treatment-comp13.pdf", height = 8.5, width = 11)
plotIndiv(treatment.known.plsda, comp = c(1,3), ind.names = FALSE,
          cex = 3, col = c(plotColors[2], plotColors[1], plotColors[3]), pch = c(19, 17, 15), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC)", 
          title = "PLS-DA by Temperature", X.label = "Component 1: 27% Explained Variance", size.xlabel = 15, Y.label = "Component 3: 7% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2") #Visualize first two components of PLS-DA with no individual sample names. Alter point size, color, shape, and line width. Include 95% confidence ellipses and use star format to visualize sample distance from centroids. Include a legend and specify the legend title. Specify the plot title and text label sizes. Use ggplot style.
#dev.off()
```

```{r}
pdf("PLSDA/figures/known-lipids-cimPlot-treatment.pdf", height = 8.5, width = 11)
cim(treatment.known.plsda, mapping = "Y", row.names = knownTransLipidData$treatment, xlab = "Lipid", ylab = "Temperature (ºC)", margins = c(8, 5), row.cex = 0.5) #Create CIM plot with lipids on the x-axis and treatment x day on the y-axis. 
dev.off()
```

## Extract VIP

```{r}
treatment.known.VIP <- as.data.frame(PLSDA.VIP(treatment.known.plsda)[["tab"]]) %>%
  rownames_to_column(., var = "lipid") %>%
  left_join(., lipidIdentifiers, by = "lipid") #Extract VIP information and save as a dataframe. Convert lipid identifiers to a column. Join with lipid identifier data to get additional ID information
head(treatment.known.VIP) #Confirm changes
```

```{r}
write.csv(treatment.known.VIP, "PLSDA/known-lipids-VIP-treatment.csv", quote = FALSE, row.names = FALSE) #Save VIP scores
```

```{r}
treatment.known.VIP %>%
  filter(VIP >= 1) %>%
  nrow(.) #188 lipids have VIP > 1
188/415 * 100 #45.3% lipids VIP > 1
```

```{r}
treatment.known.VIP %>%
  filter(VIP >= 1) %>%
  arrange(VIP) %>%
  ggplot(aes(x = VIP, y = reorder(lipid, VIP, sum))) +
  geom_point() +
  xlab("VIP Score") + ylab("Lipid") +
  theme_classic() + theme(axis.text.y = element_text(size = 4)) #Obtain significant VIP (lipids with VIP > 1). Arrange by lipid name and reorder by cumulative VIP score. Plot points and change x and y axis labels.
ggsave("PLSDA/figures/known-lipids-VIP-treatment.pdf", height = 8.5, width = 11)
```

```{r}
significantVIP <- treatment.known.VIP %>%
  filter(VIP >= 1) #Save significant VIP
```

## Pairwise tests for VIP lipids

We now know which lipids are most important for separating treatments. However, we do not know specifically which VIP distinguish between which treatment contrasts. I will use pairwise t-tests to identify which VIP are important for which contrasts. 

### 13 vs. 30

```{r}
list <- c("13", "30") #Assign treatments to examine
```

```{r}
X <- knownTransLipidData %>%
  filter(., treatment %in% list) %>%
  droplevels() #Filter knownTransLipidData for desired contrasts
Y <- as.factor(X$treatment) #Treatments for Y
X <- X[, 5:419] #Retain data only
```

```{r}
known.plsda_13v30 <- plsda(X, Y, ncomp = 3) #Run PLSDA for desired contrast
VIP_13v30 <- as.data.frame(PLSDA.VIP(known.plsda_13v30)[["tab"]]) %>%
  rownames_to_column(., var = "lipid") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
nrow(VIP_13v30)
```

```{r}
clean_13v30 <- knownTransLipidData %>%
  dplyr::filter(., treatment %in% list) %>%
  droplevels() #Filter knownTransLipidData for desired contrasts.
VIP_select_13v30 <- cbind(clean_13v30[, 1:4], 
                          (log(clean_13v30[, names(clean_13v30) %in% VIP_13v30$lipid]) %>%
                             mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
                             replace(is.na(.), 0))) %>%
  pivot_longer(., cols = 5:147, values_to = "log_norm_counts", names_to = "lipid") %>%
  group_by(., lipid) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Ensure -Inf from log transformation is converted to 0. Pivot data longer and group by lipids.
VIP_select_13v30 #Confirm changes
```

```{r}
t.test_13v30 <-do(VIP_select_13v30, tidy(t.test(.$log_norm_counts ~ .$treatment,
                                                alternative = "two.sided",
                                                mu = 0,
                                                var.equal = FALSE,
                                                conf.level = 0.95
))) #Looped t-test for all lipids with VIP > 1
t.test_13v30$p.adj <- p.adjust(t.test_13v30$p.value, method = c("fdr"), n = length(VIP_13v30$lipid)) #Adjust p value for the number of comparisons
t.test_13v30
```

```{r}
t.test_13v30 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #130 significantly different lipids
t.test_13v30 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 > estimate2) %>%
  nrow(.) #97 lipids higher in 13ºC
t.test_13v30 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 < estimate2) %>%
  nrow(.) #33 lipids higher in 30ºC
```

```{r}
t.test_13v30 %>%
  filter(., p.adj < 0.05) %>%
  right_join(x = lipidIdentifiers, y = ., by = "lipid") %>%
  write.csv("PLSDA/known-lipids-13v30-VIP.csv", quote = FALSE, row.names = FALSE) #Take t-test results and join with unique ID information to get chemical names. Save as a csv
```

```{r}
t.test_13v30 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  left_join(., VIP_13v30, by = "lipid") %>%
  mutate(., direction = case_when(estimate > 0 ~ "13",
                                  estimate < 0 ~ "30")) %>%
  mutate(., score = case_when(estimate > 0 ~ VIP,
                              estimate < 0 ~ -VIP)) %>%
  arrange(score) %>%
  ggplot(aes(x = score, y = reorder(lipid, score, sum))) +
  geom_bar(aes(fill = direction), stat = 'identity') +
  xlab("VIP Score") + ylab("Lipid") +
  scale_fill_manual(values = c(plotColors[2], plotColors[1]), 
                    name = "Temperature (ºC)",
                    breaks = c("13", "30"),
                    labels = c("13", "30")) +
  theme_classic(base_size = 15) + theme(axis.text.y = element_text(size = 6)) #Take t-test results and filter out significant lipids. Create two new columns using estimate values: one for the direction of increase, and another for positive or negative VIP. Arrange by identifier name and reorder by cumulative VIP score. Plot bars and change x and y axis labels. Add scale information.
ggsave("PLSDA/figures/significant-VIP-13v30.pdf", height = 8.5, width = 11)
```

### 13 vs. 5

```{r}
list <- c("13", "5") #Assign treatments to examine
```

```{r}
X <- knownTransLipidData %>%
  filter(., treatment %in% list) %>%
  droplevels() #Filter knownTransLipidData for desired contrasts
Y <- as.factor(X$treatment) #Treatments for Y
X <- X[, 5:419] #Retain data only
```

```{r}
known.plsda_13v5 <- plsda(X, Y, ncomp = 3) #Run PLSDA for desired contrast
VIP_13v5 <- as.data.frame(PLSDA.VIP(known.plsda_13v5)[["tab"]]) %>%
  rownames_to_column(., var = "lipid") %>%
  filter(., VIP >= 1) #Extract VIP list and filter for VIP > 1
nrow(VIP_13v5)
```

```{r}
clean_13v5 <- knownTransLipidData %>%
  dplyr::filter(., treatment %in% list) %>%
  droplevels() #Filter knownTransLipidData for desired contrasts.
VIP_select_13v5 <- cbind(clean_13v5[, 1:4], 
                         (log(clean_13v5[, names(clean_13v5) %in% VIP_13v5$lipid]) %>%
                            mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
                            replace(is.na(.), 0))) %>%
  pivot_longer(., cols = 5:175, values_to = "log_norm_counts", names_to = "lipid") %>%
  group_by(., lipid) #cbind metadata columns (1:4) and log-transformed "clean" data for VIP. Pivot data longer and group by lipids.
VIP_select_13v5 #Confirm changes
```

```{r}
t.test_13v5 <-do(VIP_select_13v5, tidy(t.test(.$log_norm_counts ~ .$treatment,
                                              alternative = "two.sided",
                                              mu = 0,
                                              var.equal = FALSE,
                                              conf.level = 0.95
))) #Looped t-test for all lipids with VIP > 1
t.test_13v5$p.adj <- p.adjust(t.test_13v5$p.value, method = c("fdr"), n = length(VIP_13v5$lipid)) #Adjust p value for the number of comparisons
t.test_13v5
```

```{r}
t.test_13v5 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  nrow(.) #61 significantly different lipids
t.test_13v5 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 > estimate2) %>%
  nrow(.) #55 lipids higher in 13ºC
t.test_13v5 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>% filter(., estimate1 < estimate2) %>%
  nrow(.) #6 lipids higher in 5ºC
```

```{r}
t.test_13v5 %>%
  filter(., p.adj < 0.05) %>%
  right_join(x = lipidIdentifiers, y = ., by = "lipid") %>%
  write.csv("PLSDA/known-lipids-13v5-VIP.csv", quote = FALSE, row.names = FALSE) #Take t-test results and join with unique ID information to get chemical names. Save as a csv
```

```{r}
t.test_13v5 %>%
  ungroup(.) %>%
  filter(., p.adj < 0.05) %>%
  left_join(., VIP_13v5, by = "lipid") %>%
  mutate(., direction = case_when(estimate > 0 ~ "13",
                                  estimate < 0 ~ "5")) %>%
  mutate(., score = case_when(estimate > 0 ~ VIP,
                              estimate < 0 ~ -VIP)) %>%
  arrange(score) %>%
  ggplot(aes(x = score, y = reorder(lipid, score, sum))) +
  geom_bar(aes(fill = direction), stat = 'identity') +
  xlab("VIP Score") + ylab("Lipid") +
  scale_fill_manual(values = c(plotColors[2], plotColors[3]), 
                    name = "Temperature (ºC)",
                    breaks = c("13", "5"),
                    labels = c("13", "5")) +
  theme_classic(base_size = 15) #Take t-test results and filter out significant lipids. Create two new columns using estimate values: one for the direction of increase, and another for positive or negative VIP. Arrange by identifier name and reorder by cumulative VIP score. Plot bars and change x and y axis labels. Add scale information.
ggsave("PLSDA/figures/significant-VIP-13v5.pdf", height = 8.5, width = 11)
```

# Validate PLSDA model

It's important to validate the PLSDA model. First, I'll run a permutation test to determine how many components to include.

```{r}
MyPerf.plsda <- perf(treatment.known.plsda, validation = "Mfold", folds = 6,  
                     progressBar = TRUE, nrepeat = 50) 

plot(MyPerf.plsda, sd = TRUE) #Overall, increasing the number of components decreases the error rate.
```

Next, I'll assess the optimal number of lipids to keep in the analysis.

```{r}
list.keepX <- c(5:10,  seq(20, 300, 10)) #list.keepX # to output the grid of values tested
X <- log(knownTransLipidData[c(5:419)]) #Assign known metabolite data to the X dataframe after log transformation
Y <- as.factor(knownTransLipidData$treatment) #Assign treatment data to the Y dataframe
```

```{r}
tune.splsda.srbct <- tune.splsda(X, Y, ncomp = 3, 
                                 validation = 'Mfold', folds = 6,
                                 measure = "BER", test.keepX = list.keepX, nrepeat = 50) #More extensive classification performance
plot(tune.splsda.srbct) #Plot results
```

```{r}
error <- tune.splsda.srbct$error.rate #Save error rate
ncomp <- tune.splsda.srbct$choice.ncomp$ncomp #Optimal number of components based on t-tests on the error rate
ncomp #3 components! That's how many I have

select.keepX <- tune.splsda.srbct$choice.keepX #Optimal number of variables to select (e.g., number of metabolite features)
select.keepX
```

```{r}
myResult.splsda.final_T <- splsda(X, Y, ncomp = ncomp, keepX = select.keepX) #Use the number of components and lipids to keep based on optimization from above
plotIndiv(myResult.splsda.final_T)
```

```{r}
#pdf("PLSDA/figures/known-lipids-sPLSDA-day-treatment-comp12.pdf", height = 8.5, width = 11)
plotIndiv(myResult.splsda.final_T, comp = c(1,2), ind.names = FALSE,
          cex = 3, col = c("#525252", "#CB181D", "#2171B5"), pch = c(15, 17, 19), point.lwd = 0.7,
          ellipse = TRUE, star = TRUE, centroid = FALSE, 
          legend = TRUE, legend.title = "Temperature (ºC)", 
          title = "sPLS-DA by Temperature ", X.label = "Component 1: 13% Explained Variance", size.xlabel = 15, Y.label = "Component 2: 20% Explained Variance", size.ylabel = 15, size.axis = 13,
          style = "ggplot2")
#dev.off()
```

# WCNA analysis for known lipids

Although I have lists of VIP associated with each pairwise comparison, there is one additional step I can take to determine which known lipids are associated with different treatment x day combinations. I will use a Weighted Correlation Network Analysis (similar to a WGCNA for gene expression) to group lipids together by abundance patterns, then correlate metabolite modules with treatment and day.

```{bash}
mkdir WCNA
mkdir WCNA/figures
```

## Data preparation

### Format data

I need to convert my dataframe such that samples are columns and lipids are rows. I also need to have a dataframe without metadata.

```{r}
rowwiseLipidData <- knownTransLipidData %>%
  dplyr::select(-c(treatment:treatment_day)) %>%
  column_to_rownames(var = "crab.ID") %>%
  t(.) %>% as.data.frame(.) %>%
  log(.) %>%
  mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
  replace(is.na(.), 0) #Take transposed lipid data for known lipids. Remove metadata and set crab ID as row names. Transpose and convert into a dataframe such that samples are columns and lipids are rows. Log-transform data. Convert -Inf to NA, then NA to 0.
head(rowwiseLipidData) #Confirm formatting
```

```{r}
rowSums(dplyr::count(rowwiseLipidData)) > 0 #Check that there are no lipids with 0 counts for all samples. Should return TRUE.  
```

### Data filtering: PoverA and genefilter

*pOverA*: Specifying the minimum count for a proportion of samples for each metabolite. Here, we are using a pOverA of 0.17. This is because we have 69 samples with a minimum of n = 12 samples per temperature Therefore, we will accept lipids that are present in 12/69 = 0.17 of the samples because we expect different lipids by temperature as demonstrated by PLSDA analysis. We are further setting the minimum value of lipids to 0.01 (median normalized), such that 17% of the samples must have a non-zero normalized metabolite presence in order for the metabolite to remain in the data set.  

Filter in the package "genefilter". Pre-filtering our dataset to reduce the memory size dataframe, increase the speed of the transformation and testing functions, and improve quality of statistical analysis by removing low-coverage counts. Removed counts could represent outliers in the data and removing these improves sensitivity of statistical tests.

```{r}
filt <- filterfun(pOverA(0.17, 0.01)) #Define the filter
gfilt <- genefilter(rowwiseLipidData, filt) #Create filter for the metabolite data
```

```{r}
keep <- rowwiseLipidData[gfilt,] #Identify lipids to keep by count filter
n.keep <- rownames(keep) #Identify metabolite lists

rowwiseLipidData_filt <- as.data.frame(rowwiseLipidData[which(rownames(rowwiseLipidData) %in% n.keep),]) #Metabolite count data filtered in PoverA, P percent of the samples have counts over A
```

```{r}
#How many rows do we have before and after filtering?
nrow(rowwiseLipidData) #Before
nrow(rowwiseLipidData_filt) #After
```

All 415 known lipids will be used in downstream analysis.

```{r}
#Checking that all row and column names match. Should return "TRUE"
all(rownames(lipidomicsMetadata$sample_id) %in% colnames(rowwiseLipidData_filt))
all(rownames(lipidomicsMetadata$sample_id) == colnames(rowwiseLipidData_filt)) 
```

### Outlier detection

I will identify outliers visually through a clustering analysis.

#### Lipids

```{r}
sampleTree <- hclust(dist(rowwiseLipidData), method = "average") #Perform clustering analysis
```

```{r}
#pdf("WCNA/figures/lipid-outliers.pdf", height = 8.5, width = 11)
plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 0.8, cex.axis = 0.8, cex.main = 2) #Plot cluster dendogram
#dev.off()
```

```{r}
# rowwiseLipidData %>%
#   rownames_to_column(., var = "lipid") %>%
#   filter(., lipid != "PC 34:1 Isomer A") %>% 
#   column_to_rownames(., var = "lipid") #Remove potential outlier
```

```{r}
# sampleTree <- hclust(dist(rowwiseLipidData %>%
#   rownames_to_column(., var = "lipid") %>%
#   filter(., lipid != "PC 34:1 Isomer A") %>% 
#   column_to_rownames(., var = "lipid")), method = "average") #Perform clustering analysis without potential outlier
```

```{r}
# pdf("WCNA/figures/lipid-outliers.pdf", height = 8.5, width = 11)
# plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 0.8, cex.axis = 0.8, cex.main = 2) #Plot cluster dendogram
# dev.off()
```

There's so much lipid data, but it doesn't seem like outlier removal changes the clustering patterns. I'll keep the potential outlier in the data.

#### Samples

```{r}
rowwiseLipidData <- t(rowwiseLipidData) %>% as.data.frame(.) #Transpose such that samples are in rows and lipids are in columns.  
head(rowwiseLipidData) #Confirm changes
```

Construct a new cluster dendogram to visually identify sample outliers.

```{r}
sampleTree <- hclust(dist(rowwiseLipidData), method = "average") #Perform clustering analysis
```

```{r}
#pdf("WCNA/figures/sample-outliers.pdf", height = 8.5, width = 11)
plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
#dev.off()
```

```{r}
# rowwiseLipidData[-c(40, 28, 30),] #Remove 303, 304, and 306
```

```{r}
# sampleTree <- hclust(dist(rowwiseLipidData[-c(40, 28, 30),]), method = "average") #Perform clustering analysis without potential outliers
```

```{r}
#Recreate clustering without potential outliers
#pdf("WCNA/figures/sample-outliers.pdf", height = 8.5, width = 11)
# plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
#dev.off()
```

304, 303, and 606 look like they could be outliers (all from 30ºC treatment at day 3). I did this analysis with and without those samples and it did not change the sample clustering, so I will not remove these outliers.

## Network construction and consensus module detection

### Choosing a soft-thresholding power: Analysis of a network topology β  

The soft thresholding power (β) is the number to which the co-expression similarity is raised to calculate adjacency. The function `pickSoftThreshold` performs a network topology analysis. The user chooses a set of candidate powers, however the default parameters are suitable values.  

```{r, message=FALSE, warning=FALSE}
allowWGCNAThreads()
powers <- c(c(1:20), seq(from = 12, to=20, by=2)) #Create a string of numbers from 1 through 10, and even numbers from 10 through 20
sft <-pickSoftThreshold(rowwiseLipidData, powerVector = powers, verbose = 5) # Call the network topology analysis function
```

```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# # # Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# # # this line corresponds to using an R^2 cut-off
abline(h=0.85,col="red")
# # # Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

When choosing a soft thresholding power, want to choose the lowest number that reaches the R<sup>2</sup> cutoff. From this data, it appears that the **soft thresholding power is 9**.

### Identify modules using `blockwiseModules`  

Use `blockwiseModules` to identify modules of lipids.  

Settings used: 

networkType = "unsigned" 
deepSplit = 2
pamRespectsDendro = F
minModuleSize = 5
maxBlockSize = 4000
reassignThreshold = 0
mergeCutHeight = 0.25

```{r, echo=TRUE, warning=FALSE, message=FALSE}

picked_power = 9
temp_cor <- cor       
cor <- WGCNA::cor # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(rowwiseLipidData,                         # <= input here
                          
                          # == Adjacency Function ==
                          power = picked_power,               # <= power here
                          networkType = "unsigned",
                          
                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,                  
                          maxBlockSize = 4000,
                          
                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,
                          
                          # == TOM == Archive the run results in TOM file (saves time) but it doesn't save a file
                          saveTOMs = F,
                          saveTOMFileBase = "ER",
                          
                          # == Output Options
                          numericLabels = T,
                          verbose = 3)

cor <- temp_cor     # Return cor function to original namespace
```

```{r}
mergedColors = netwk$colors # Identify labels as numbers 
table(mergedColors)
```

Module sizes are as follows: 

0    1   2   3   4   5   6   7   8   9  10  11  12  13  14  15 
23 136  52  37  25  23  22  20  17  11  10   9   9   8   7   6 

```{r}
# Plot the dendrogram and the module colors underneath

#pdf("WCNA/figures/cluster-dendogram-mergedME.pdf")
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
#dev.off()
```

### Relate modules to sample information

``` {r, echo=TRUE, warning=FALSE, message=FALSE}
module_df <- data.frame(
  Lipid = names(netwk$colors),
  colors = netwk$colors)

write.csv(module_df, "WCNA/lipid_modules.csv")

# Get Module Eigengenes per cluster
MEs <- moduleEigengenes(rowwiseLipidData, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs <- orderMEs(MEs)
module_order = names(MEs) %>% gsub("ME","", .)

# Add Sample names
MEs0 <- MEs
MEs0$crab.ID = row.names(MEs)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-crab.ID) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=crab.ID, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-Sample Relationships", y = "Modules", fill = "corr")
```

### Relate modules to treatment and day

Prepare trait data. Data has to be numeric, so I will substitute temperatures and days for numeric values. To do this, I make a dataframe that has a column for each treatment x day and a row for samples. Populate a 1 for samples that match each treatment x day and a 0 for samples not matching respective treatment x day. This process changes treatments and days from a categorical variable into a binary variable. This will allow for correlations between mean eigengenes and treatment or day.  

```{r}
datTraits <- lipidomicsMetadata %>%
  mutate(., "13ºC" = case_when(treatment == "13" ~ 1,
                               treatment != "13" ~ 0)) %>%
  mutate(., "5ºC" = case_when(treatment == "5" ~ 1,
                              treatment != "5" ~ 0)) %>%
  mutate(., "30ºC" = case_when(treatment == "30" ~ 1,
                               treatment != "30" ~ 0)) %>%
  dplyr::select(., -c(2:4)) #Copy dataframe into datTraits, then use a series of case_when commands to create individual columns for each treatment or day, with 1 indicating that sample is part of the group, and 0 indicating that sample is not part of the group. Remove previous treatment classification columns. 
rownames(datTraits) <- datTraits$crab.ID #Convert crab.ID into rownames.
datTraits <- datTraits %>%
  dplyr::select(., -crab.ID) #Remove the crab.ID column
head(datTraits) #Confirm dataframe creation
```

```{r}
#Define numbers of lipids and samples and view 
nMetabolites <- ncol(rowwiseLipidData)
nSamples <- nrow(rowwiseLipidData)

nMetabolites
nSamples
```

We have 415 lipids and 69 samples.   

Next correlate the trait matrix (treatment, day) with eigengenes (modules).  

```{r}
moduleTraitCor <- cor(MEs, datTraits, use = "p") #Correlations of traits with eigengenes
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples) #Get p-values for correlations
head(moduleTraitCor %>% as.data.frame())
head(moduleTraitPvalue %>% as.data.frame())
```

```{r}
moduleTraitTree <- hclust(dist(t(moduleTraitCor)), method = "average") #Create cluster dendogram for module-trait correlations
```

```{r}
#pdf(file = "WCNA/figures/module-trait-cluster-dendogram.pdf", height = 8.5, width = 11)
plot(moduleTraitTree) #Plot cluster dendogram
#dev.off()
```

```{r}
# Correlations of lipids with eigengenes. Calculate correlations between ME's and groups 
moduleGeneCor <- cor(MEs, rowwiseLipidData) #Correlate eigengenes with lipids
moduleGenePvalue <- corPvalueStudent(moduleGeneCor, nSamples) #Calculate p-values for metabolite-eigengene correlations
head(moduleGeneCor %>% as.data.frame)
head(moduleGenePvalue %>% as.data.frame(.))
```

## Plot module-trait associations

```{r, echo=TRUE, warning=FALSE, message=FALSE}
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",signif(moduleTraitPvalue, 1), ")", sep = "") #Create a matrix with the module-trait correlation and p-values
dim(textMatrix) <- dim(moduleTraitCor) #Ensure this matrix has the appropriate dimensions
head(textMatrix) #Confirm matrix creation
```

```{r}
#pdf("WCNA/figures/module-trait-relationships.pdf", height = 8.5, width = 11)
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y = 1.5, cex.lab.x = 1.5, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 1, zlim = c(-1,1), main = paste("Module-trait relationships"), cex.main = 2) #Use the textMatrix to create a heatmap with correlations between modules and the various treatments.
#dev.off()
```

```{r, echo=TRUE, warning=FALSE, message=FALSE}
heatmappval <- signif(moduleTraitPvalue, 1) #Create list of pvalues for eigengene correlation with specific traits

row_dend <- dendsort(hclust(dist(moduleTraitCor))) #Create dendograms for rows
col_dend <- dendsort(hclust(dist(t(moduleTraitCor)))) #Create dendograms for columns

trait_order <- c("5ºC", "13ºC", "30ºC") #Order of traits for heatmap
```

```{r}
#pdf(file = "WCNA/figures/module-trait-relationship-heatmap.pdf", height = 8.5, width = 8.5)
ht <- Heatmap(moduleTraitCor, name = "Eigengene", column_title = "Module-Group Eigengene Correlation",
              col = blueWhiteRed(50), 
              row_names_side = "left", 
              row_dend_side = "left",
              width = unit(5, "in"), 
              height = unit(4.5, "in"), 
              column_dend_reorder = TRUE,
              cluster_columns = col_dend,
              row_dend_reorder = FALSE,  
              #column_split = 3, 
              #row_split = 3, 
              #column_dend_height = unit(.5, "in"),
              cluster_rows = row_dend, 
              #column_order = trait_order, 
              #row_gap = unit(2.5, "mm"), 
              border = TRUE,
              cell_fun = function(j, i, x, y, w, h, col) {
                if(heatmappval[i, j] < 0.05) {
                  grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
                }
                else {
                  grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
                }},
              column_names_rot = 45,
              column_names_gp =  gpar(fontsize = 12, border = FALSE),
              column_title_gp = gpar(fontsize = 20),
              row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE)) #Create a heatmap object
draw(ht) #Draw heatmap
#dev.off()
```

```{r}
#svg(file = "WCNA/figures/module-trait-relationship-heatmap.svg", height = 8.5, width = 8.5)
ht <- Heatmap(moduleTraitCor, name = "Correlation", column_title = "Module-Group Eigengene Correlation",
              row_names_side = "left", 
              row_dend_side = "left",
              width = unit(5, "in"), 
              height = unit(4.5, "in"), 
              column_dend_reorder = TRUE, 
              cluster_columns = col_dend,
              row_dend_reorder = FALSE,  
              #column_split = 3, 
              #row_split = 3, 
              #column_dend_height = unit(.5, "in"),
              cluster_rows = row_dend, 
              #column_order = trait_order, 
              #row_gap = unit(2.5, "mm"), 
              border = TRUE,
              cell_fun = function(j, i, x, y, w, h, col) {
                if(heatmappval[i, j] < 0.05) {
                  grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
                }
                else {
                  grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
                }},
              column_names_rot = 45,
              column_names_gp =  gpar(fontsize = 12, border = FALSE),
              column_title_gp = gpar(fontsize = 20),
              row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE)) #Create a heatmap object
draw(ht) #Draw heatmap
#dev.off()
```

## Plot mean eigengene values for each module

```{r}
#Ensure metadata columns are factors
lipidomicsMetadata$crab.ID <- as.factor(lipidomicsMetadata$crab.ID)
lipidomicsMetadata$treatment <- as.factor(lipidomicsMetadata$treatment)
lipidomicsMetadata$day <- as.factor(lipidomicsMetadata$day)
lipidomicsMetadata$treatment <- as.factor(lipidomicsMetadata$treatment)
```

```{r}
mME_meta <- merge(mME, lipidomicsMetadata, by = "crab.ID") %>%
  rename(Module = name) #Create new dataframe with metadata
head(mME_meta) #Confirm dataframe creation
mME_meta$treatment <- factor(mME_meta$treatment, levels = c("5", "13", "30")) #Reorder levels
levels(mME_meta$treatment) #Confirm levels were reordered
```

```{r}
write.csv(mME_meta, "WCNA/module-expression.csv", quote = FALSE, row.names = FALSE) #Save module expression dataframe
```

First, I'm going to look at boxplots for eigengene expression by treatment.

```{r, warning = FALSE, message = FALSE}
#pdf("WCNA/figures/eigengene-expression-boxplot.pdf", height = 8.5, width = 11)
mME_meta %>%
  ggplot(aes(x = treatment, y = value, colour = treatment)) +
  facet_wrap(~ Module, scales = "free_y") +
  ylab("Module Expression") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey")+
  geom_boxplot(width = 0.5, position = position_dodge(width = 0.5), alpha = 0.7) +
  geom_point(pch = 21, position = position_dodge(width = 0.5)) +
  scale_fill_manual(name = "Temperature (ºC)", 
                    values = rev(plotColors),
                    labels = c("5ºC", "13ºC", "30ºC")) +
  scale_colour_manual(name = "Temperature (ºC)", 
                      values = rev(plotColors),
                      labels = c("5ºC", "13ºC", "30ºC")) +
  xlab("") + #Axis titles
  theme_classic(base_size = 15) + theme(axis.text.x = element_text(color = "white"),
                                        axis.ticks.x = element_blank()) #Create a boxplot with data points for module expression on the y-axis and values for each treatment x day combination. Facet by module eigengene. Add a horizontal line at y = 0.
#dev.off()
```

I'm going to make a similar plot, but use dots instead to see if that makes the trends clearer.

```{r, warning = FALSE, message = FALSE}
#pdf("WCNA/figures/eigengene-expression-dotplot.pdf", height = 8.5, width = 11)
mME_meta %>%
  ggplot(aes(x = treatment, y = value)) +
  facet_grid(~Module) +
  ylab("Eigengene Expression") +
  geom_hline(yintercept = 0, linetype ="dashed", color = "grey")+
  geom_point(aes(fill = treatment, color = treatment), size = 3, pch = 21, position = position_dodge(width = 0.5)) +
  geom_smooth(aes(group = 1), se = TRUE, show.legend = NA, color="black") +
  scale_fill_manual(name = "Temperature (ºC)", 
                    values = rev(plotColors),
                    labels = c("5ºC", "13ºC", "30ºC")) +
  scale_colour_manual(name = "Temperature (ºC)", 
                      values = rev(plotColors),
                      labels = c("5ºC", "13ºC", "30ºC")) +
  xlab("") + #Axis titles
  theme_classic(base_size = 15) + theme(axis.text.x = element_blank(), 
                                        axis.ticks.x = element_blank(),
                                        legend.position = "bottom", 
                                        legend.text = element_text(color = "black", size = 12), 
                                        strip.text.x = element_text(size = 14, color = "black", face="bold"))
#dev.off()
```

```{r}
mME_meta$treatment <- factor(mME_meta$treatment, levels = c("13", 
                                                            "5", 
                                                            "30")) #Reorder levels
levels(mME_meta$treatment) #Confirm levels were reordered
```

```{r}
lipid_rel_change <- mME_meta %>%
  dplyr::select(treatment, crab.ID, Module, value) %>%
  group_by(treatment, Module) %>%
  summarise(mean = mean(value)) %>%
  group_by(treatment, Module) %>%
  arrange(treatment, .by_group = TRUE) %>%
  group_by(Module) %>%
  mutate(lipid_expression = ((mean-dplyr::first(mean))/abs(dplyr::first(mean)))) %>%
  dplyr::select(Module, treatment, lipid_expression) #Take the dataframe with module information and metadata, and keep only the treatment, crab.ID, module, and module eigengene values. Group by treatment and Module, then calculate mean eigengene expression. Arrange by treatment, group by module again, then calculate relative change in expression for each module relative to 13ºC at day 3. 
lipid_rel_change #Confirm calculations
```

```{r}
write.csv(lipid_rel_change, "WCNA/lipids_relative_change.csv", quote = FALSE, row.names = FALSE)
```

# Create lists of lipids in each module

For each module, I want the metabolite name, but I also want all of the annotation information provided by the sequencing facility.

```{r}
module0_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 0) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
nrow(module0_lipids) #23 lipids
head(module0_lipids)
write_delim(module0_lipids, "metaboanalyst/module0_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module1_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 1) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module1_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #136 lipids
head(module1_lipids)
write_delim(module1_lipids, "metaboanalyst/module1_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module2_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 2) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module2_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #52 lipids
head(module2_lipids)
write_delim(module2_lipids, "metaboanalyst/module2_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module3_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 3) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module3_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #37 lipids
head(module3_lipids)
write_delim(module3_lipids, "metaboanalyst/module3_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module4_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 4) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module4_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #25 lipids
head(module4_lipids)
write_delim(module4_lipids, "metaboanalyst/module4_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module5_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 5) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module5_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #23 lipids
head(module5_lipids)
write_delim(module5_lipids, "metaboanalyst/module5_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module6_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 6) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module6_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #22 lipids
head(module6_lipids)
write_delim(module6_lipids, "metaboanalyst/module6_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module7_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 7) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module7_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #20 lipids
head(module7_lipids)
write_delim(module7_lipids, "metaboanalyst/module7_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module8_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 8) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module8_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #17 lipids
head(module8_lipids)
write_delim(module8_lipids, "metaboanalyst/module8_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module9_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 9) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module9_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #11 lipids
head(module9_lipids)
write_delim(module9_lipids, "metaboanalyst/module9_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module10_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 10) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module10_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #10 lipids
head(module10_lipids)
write_delim(module10_lipids, "metaboanalyst/module10_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module11_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 11) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module11_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #9 lipids
head(module11_lipids)
write_delim(module11_lipids, "metaboanalyst/module11_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module12_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 12) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module12_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #9 lipids
head(module12_lipids)
write_delim(module12_lipids, "metaboanalyst/module12_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module13_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 13) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module13_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #8 lipids
head(module13_lipids)
write_delim(module13_lipids, "metaboanalyst/module13_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module14_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 14) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module14_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #7 lipids
head(module14_lipids)
write_delim(module14_lipids, "metaboanalyst/module14_lipids.tsv", delim = "\t", col_names = TRUE)
```

```{r}
module15_lipids <- module_df %>%
  dplyr::rename(., Module = colors) %>%
  filter(., Module == 15) %>%
  dplyr::select(., Lipid) %>% 
  dplyr::rename(lipid = "Lipid") %>%
  left_join(., rawLipidomicsData, by = "lipid") %>%
  right_join(lipidIdentifiers, ., by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., 1:5) #Take dataframe with modules and lipids, change colors to Module, and select lipids for a given module. Keep only the Lipid column and rename. Join with the raw lipidomics data and lipid identifiers. Select columns of interest
module15_lipids %>% dplyr::select(lipid) %>% unique(.) %>% nrow(.) #6 lipids
head(module15_lipids)
write_delim(module15_lipids, "metaboanalyst/module15_lipids.tsv", delim = "\t", col_names = TRUE)
```

# Pathway analysis

The final step in this workflow is to understand the various lipid pathways represented in each module eigengene. To do this, I will conduct a manual pathway analysis and identify VIP present in each significant cluster, and also use MetaboAnalyst.

## Establish heatmap formatting

I will put together a color scheme and annotation information for rows (VIP status) and columns (temperature).

```{r}
heatmapColors <- rev(brewer.pal("PRGn", n = 9))
```

```{r}
lipidomicsAvgAnnotation <- lipidomicsMetadata %>%
  mutate(., Treatment = case_when(treatment == "13" ~ "13ºC",
                                  treatment == "30" ~ "30ºC",
                                  treatment == "5" ~ "5ºC")) %>%
  dplyr::select(treatment, Treatment) %>%
  unique(.) #Create treatment column. Keep only columns of interest and retain unique rows.
rownames(lipidomicsAvgAnnotation) <- lipidomicsAvgAnnotation$treatment #Change treatment_day to rownames
lipidomicsAvgAnnotation <- lipidomicsAvgAnnotation %>%
  dplyr::select(-treatment) #Remove treatment column
head(lipidomicsAvgAnnotation) #Confirm changes
```

```{r}
knownTransLipidData$treatment <- factor(knownTransLipidData$treatment, 
                                        levels=c("13", 
                                                 "5",
                                                 "30")) #Reorder levels for visualization
```

```{r}
VIPannotation <- knownTransLipidData %>%
  dplyr::select(-c(crab.ID:treatment_day)) %>%
  t(.) %>% as.data.frame(.) %>%
  rownames_to_column(., var = "lipid") %>%
  dplyr::select("lipid") %>%
  mutate(., Status = case_when(lipid %in% significantVIP$lipid & (lipid %in% t.test_13v30$lipid | lipid %in% t.test_13v5$lipid) ~ "Both",
                               lipid %in% significantVIP$lipid ~ "Overall",
                               lipid %in% t.test_13v30$lipid | lipid %in% t.test_13v5$lipid ~ "Pairwise")) %>%
  mutate(., Status = case_when(is.na(Status) == TRUE ~ "Neither",
                               is.na(Status) == FALSE ~ Status)) %>%
  column_to_rownames(var = "lipid") #Take known lipid data and remove extra annotation columns. Convert rownames to lipid column and select only that column. Create a new column for VIP status (both = present in overall and at least one pairwise list; overall; pairwise = present in at least one pairwise list). Convert NA in status column to "neither". Convert lipid column back to rownames
head(VIPannotation)
```

```{r}
VIPannotation$Status <- factor(VIPannotation$Status, 
                               levels=c("Both", 
                                        "Overall",
                                        "Pairwise",
                                        "Neither")) #Reorder levels for visualization
```

```{r}
lipidomicsColors <- list(Treatment = c("5ºC" = plotColors[3],
                                       "13ºC" = plotColors[2],
                                       "30ºC" = plotColors[1]),
                         Status = c("Both" = "goldenrod4",
                                    "Overall" = "goldenrod3",
                                    "Pairwise" = "goldenrod2",
                                    "Neither" = "gold")) #List of colors for column and row annotations
lipidomicsColors #Column annotation colors
```

## Manual pathway analysis

I want to do a rough analysis with phosphatidylethanolamine (PE) and phosphatidylcholines (PC) compounds, since Chapelle 1978 and 1986 found them most responsive to temperature. I'll also examine the other kids of glycerophospholipids — phosphatidylserine (PS) and phosphatidylinositol (PI) — since glycerophsopholipids are involved in cell membranes. Phosphatidic acid (PA) is another glycerophospholipid, but it is not present in this dataset. Finally, I'll look at tryglycerides, which are important energy storage molecules.

```{bash}
mkdir metaboanalyst
mkdir metaboanalyst/figures
```

### Glycerophospholipids

#### Phosphatidylcholines (PC)

```{r}
PCLipids <- rawLipidomicsData %>%
  slice(., 151:390) %>%
  dplyr::select(lipid) #Create a new object with only PC lipid names
nrow(PCLipids) #There are 240 PC lipids, but not all of them may have accompanying PubChem IDs (not all known)
```

```{r}
PCData <- knownTransLipidData %>%
  dplyr::select(1:4, any_of(PCLipids$lipid)) %>%
  column_to_rownames(var = "crab.ID") #Take known lipid data and select metadata columns and columns with names that match PC lipids. Convert crab ID to column name
head(PCData) #Confirm dataframe creation
ncol(PCData) - 3 #There are 141 known PC lipids
```

```{r}
#pdf("metaboanalyst/figures/PC-heatmap.pdf", width = 11, height = 8.5)
pheatmap((PCData %>% 
            dplyr::select(., -c(day, treatment_day)) %>%
            group_by(treatment) %>%
            mutate(across(where(is.numeric), log)) %>%
            mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
            replace(is.na(.), 0) %>%
            mutate(across(where(is.numeric), scale)) %>%
            summarize_all(funs(mean(., na.rm = TRUE))) %>%
            column_to_rownames(var = "treatment") %>%
            t(.)), cluster_row = TRUE, show_rownames = TRUE, fontsize_row = 5, 
         cluster_cols = FALSE, show_colnames = FALSE, 
         scale = "row", 
         color = heatmapColors, 
         annotation_row = VIPannotation %>%
           filter(., rownames(VIPannotation) %in% colnames(PCData)), 
         annotation_col = lipidomicsAvgAnnotation, 
         annotation_colors = lipidomicsColors, 
         name = "Z-Score") #Take PC data and remove unnecessary metadata columns. Group by treatment and log-transform numeric columns. Convert -Inf to NA, then NA to 0. Scale all values to obtain z-scores. Average lipid z-scores across treatment. Convert treatment column to rownames. Transpose to obtain matrix. Create heatmap using color schemes and annotations created above.
#dev.off()
```

#### Phosphatidylethanolamine (PE)

```{r}
PELipids <- rawLipidomicsData %>%
  slice(., 391:447, 458:459) %>%
  dplyr::select(lipid) #Create a new object with only PE lipid names
nrow(PELipids) #There are 59 PE lipids, but not all of them may have accompanying PubChem IDs (not all known)
```

```{r}
PEData <- knownTransLipidData %>%
  dplyr::select(1:4, any_of(PELipids$lipid)) %>%
  column_to_rownames(var = "crab.ID") #Take known lipid data and select metadata columns and columns with names that match PE lipids. Convert crab ID to column name
head(PEData) #Confirm dataframe creation
ncol(PEData) - 3 #There are 49 known PE lipids
```

```{r}
#pdf("metaboanalyst/figures/PE-heatmap.pdf", width = 11, height = 8.5)
pheatmap((PEData %>% 
            dplyr::select(., -c(day, treatment_day)) %>%
            group_by(treatment) %>%
            mutate(across(where(is.numeric), log)) %>%
            mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
            replace(is.na(.), 0) %>%
            mutate(across(where(is.numeric), scale)) %>%
            summarize_all(funs(mean(., na.rm = TRUE))) %>%
            column_to_rownames(var = "treatment") %>%
            t(.)), cluster_row = TRUE, show_rownames = TRUE, fontsize_row = 5, 
         cluster_cols = FALSE, show_colnames = FALSE, 
         scale = "row", 
         color = heatmapColors, 
         annotation_row = VIPannotation %>%
           filter(., rownames(VIPannotation) %in% colnames(PEData)), 
         annotation_col = lipidomicsAvgAnnotation, 
         annotation_colors = lipidomicsColors, 
         name = "Z-Score") #Take PE data and remove unnecessary metadata columns. Group by treatment and log-transform numeric columns. Convert -Inf to NA, then NA to 0. Scale all values to obtain z-scores. Average lipid z-scores across treatment. Convert treatment column to rownames. Transpose to obtain matrix. Create heatmap using color schemes and annotations created above.
#dev.off()
```

#### Phosphatidylserines (PS)

```{r}
PSLipids <- rawLipidomicsData %>%
  slice(., 486:493) %>%
  dplyr::select(lipid) #Create a new object with only PS lipid names
nrow(PSLipids) #There are 8 PS lipids, but not all of them may have accompanying PubChem IDs (not all known)
```

```{r}
PSData <- knownTransLipidData %>%
  dplyr::select(1:4, any_of(PSLipids$lipid)) %>%
  column_to_rownames(var = "crab.ID") #Take known lipid data and select metadata columns and columns with names that match PS lipids. Convert crab ID to column name
head(PSData) #Confirm dataframe creation
ncol(PSData) - 3 #There are 7 known PS lipids
```

```{r}
#pdf("metaboanalyst/figures/PS-heatmap.pdf", width = 11, height = 8.5)
pheatmap((PSData %>% 
            dplyr::select(., -c(day, treatment_day)) %>%
            group_by(treatment) %>%
            mutate(across(where(is.numeric), log)) %>%
            mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
            replace(is.na(.), 0) %>%
            mutate(across(where(is.numeric), scale)) %>%
            summarize_all(funs(mean(., na.rm = TRUE))) %>%
            column_to_rownames(var = "treatment") %>%
            t(.)), cluster_row = TRUE, show_rownames = TRUE, fontsize_row = 5, 
         cluster_cols = FALSE, show_colnames = FALSE, 
         scale = "row", 
         color = heatmapColors, 
         annotation_row = VIPannotation %>%
           filter(., rownames(VIPannotation) %in% colnames(PSData)), 
         annotation_col = lipidomicsAvgAnnotation, 
         annotation_colors = lipidomicsColors, 
         name = "Z-Score") #Take PS data and remove unnecessary metadata columns. Group by treatment and log-transform numeric columns. Convert -Inf to NA, then NA to 0. Scale all values to obtain z-scores. Average lipid z-scores across treatment. Convert treatment column to rownames. Transpose to obtain matrix. Create heatmap using color schemes and annotations created above.
#dev.off()
```

#### Phosphatidylinositols (PI)

```{r}
PILipids <- rawLipidomicsData %>%
  slice(., 460:481) %>%
  dplyr::select(lipid) #Create a new object with only PI lipid names
nrow(PILipids) #There are 22 PI lipids, but not all of them may have accompanying PubChem IDs (not all known)
```

```{r}
PIData <- knownTransLipidData %>%
  dplyr::select(1:4, any_of(PILipids$lipid)) %>%
  column_to_rownames(var = "crab.ID") #Take known lipid data and select metadata columns and columns with names that match PI lipids. Convert crab ID to column name
head(PIData) #Confirm dataframe creation
ncol(PIData) - 3 #There are 11 known PI lipids
```

```{r}
#pdf("metaboanalyst/figures/PI-heatmap.pdf", width = 11, height = 8.5)
pheatmap((PIData %>% 
            dplyr::select(., -c(day, treatment_day)) %>%
            group_by(treatment) %>%
            mutate(across(where(is.numeric), log)) %>%
            mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
            replace(is.na(.), 0) %>%
            mutate(across(where(is.numeric), scale)) %>%
            summarize_all(funs(mean(., na.rm = TRUE))) %>%
            column_to_rownames(var = "treatment") %>%
            t(.)), cluster_row = TRUE, show_rownames = TRUE, fontsize_row = 5, 
         cluster_cols = FALSE, show_colnames = FALSE, 
         scale = "row", 
         color = heatmapColors, 
         annotation_row = VIPannotation %>%
           filter(., rownames(VIPannotation) %in% colnames(PIData)), 
         annotation_col = lipidomicsAvgAnnotation, 
         annotation_colors = lipidomicsColors, 
         name = "Z-Score") #Take PI data and remove unnecessary metadata columns. Group by treatment and log-transform numeric columns. Convert -Inf to NA, then NA to 0. Scale all values to obtain z-scores. Average lipid z-scores across treatment. Convert treatment column to rownames. Transpose to obtain matrix. Create heatmap using color schemes and annotations created above.
#dev.off()
```

### Triglycerides

```{r}
TGLipids <- rawLipidomicsData %>%
  slice(., 536:612) %>%
  dplyr::select(lipid) #Create a new object with only TG lipid names
nrow(TGLipids) #There are 77 TG lipids, but not all of them may have accompanying PubChem IDs (not all known)
```

```{r}
TGData <- knownTransLipidData %>%
  dplyr::select(1:4, any_of(TGLipids$lipid)) %>%
  column_to_rownames(var = "crab.ID") #Take known lipid data and select metadata columns and columns with names that match TG lipids. Convert crab ID to column name
head(TGData) #Confirm dataframe creation
ncol(TGData) - 3 #There are 55 known TG lipids
```

```{r}
#pdf("metaboanalyst/figures/TG-heatmap.pdf", width = 11, height = 8.5)
pheatmap((TGData %>% 
            dplyr::select(., -c(day, treatment_day)) %>%
            group_by(treatment) %>%
            mutate(across(where(is.numeric), log)) %>%
            mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
            replace(is.na(.), 0) %>%
            mutate(across(where(is.numeric), scale)) %>%
            summarize_all(funs(mean(., na.rm = TRUE))) %>%
            column_to_rownames(var = "treatment") %>%
            t(.)), cluster_row = TRUE, show_rownames = TRUE, fontsize_row = 5, 
         cluster_cols = FALSE, show_colnames = FALSE, 
         scale = "row", 
         color = heatmapColors, 
         annotation_row = VIPannotation %>%
           filter(., rownames(VIPannotation) %in% colnames(TGData)), 
         annotation_col = lipidomicsAvgAnnotation, 
         annotation_colors = lipidomicsColors, 
         name = "Z-Score") #Take TG data and remove unnecessary metadata columns. Group by treatment and log-transform numeric columns. Convert -Inf to NA, then NA to 0. Scale all values to obtain z-scores. Average lipid z-scores across treatment. Convert treatment column to rownames. Transpose to obtain matrix. Create heatmap using color schemes and annotations created above.
#dev.off()
```

## VIP "enrichment" analysis

The second step of this workflow is to analyze the abundance patterns and associated functions/pathways of significant VIP.

### All VIP

#### Make heatmaps

```{r}
#pdf("metaboanalyst/figures/all_VIP-average.pdf", height = 8.5, width = 11)
pheatmap((knownTransLipidData %>%
            dplyr::select(treatment, any_of(significantVIP$lipid)) %>%
            group_by(., treatment) %>%
            summarize_all(funs(mean(., na.rm = TRUE))) %>%
            column_to_rownames(var = "treatment") %>%
            t(.) %>% as.data.frame(.) %>%
            log(.) %>%
            mutate_if(is.numeric, list(~na_if(., -Inf))) %>%
            replace(is.na(.), 0) %>%
            as.matrix()), cluster_row = TRUE, fontsize_row = 4, show_rownames = TRUE,
         cluster_cols = FALSE, show_colnames = FALSE, 
         scale = "row", 
         color = heatmapColors, annotation_col = lipidomicsAvgAnnotation, annotation_colors = lipidomicsColors, 
         name = "Abundance")
#dev.off()
```

```{r}
#pdf("metaboanalyst/figures/all_VIP-zscore.pdf", height = 8.5, width = 11)
pheatmap((knownTransLipidData %>%
            dplyr::select(treatment, any_of(significantVIP$lipid)) %>%
            group_by(., treatment) %>%
            mutate(across(where(is.numeric), log)) %>%
            mutate(across(where(is.numeric), scale)) %>%
            summarize_all(funs(mean(., na.rm = TRUE))) %>%
            column_to_rownames(var = "treatment") %>%
            t(.)), cluster_row = TRUE, show_rownames = TRUE, fontsize_row = 4,
         cluster_cols = FALSE, show_colnames = FALSE, 
         scale = "row", 
         color = heatmapColors, annotation_col = lipidomicsAvgAnnotation, annotation_colors = lipidomicsColors, 
         name = "Z-Score")
#dev.off()
```

```{r}
#svg("metaboanalyst/figures/all_VIP-zscore.svg", height = 8.5, width = 11)
pheatmap((knownTransLipidData %>%
            dplyr::select(treatment, any_of(significantVIP$lipid)) %>%
            group_by(., treatment) %>%
            mutate(across(where(is.numeric), log)) %>%
            mutate(across(where(is.numeric), scale)) %>%
            summarize_all(funs(mean(., na.rm = TRUE))) %>%
            column_to_rownames(var = "treatment") %>%
            t(.)), cluster_row = TRUE, show_rownames = TRUE, fontsize_row = 4,
         cluster_cols = FALSE, show_colnames = FALSE, 
         scale = "row", 
         color = heatmapColors, annotation_col = lipidomicsAvgAnnotation, annotation_colors = lipidomicsColors, 
         name = "Z-Score")
#dev.off()
```

#### Metaboanalyst

The next thing I want to do with the list of all VIP is to add PubChem and KEGG annotations. This will allow me to upload the list into MetaboAnalyst to conduct pathway assignment and check for enriched pathways.

```{r}
significantVIP %>%
  dplyr::select(., lipid) %>% 
  left_join(., rawLipidomicsData, by = "lipid") %>%
  left_join(., lipidIdentifiers, by = c("lipid", "identifier", "INCHIKEY")) %>%
  dplyr::select(., lipid, identifier, PubChem.CID, Chemical.Name, INCHIKEY) %>%
  write.table("metaboanalyst/allVIP_lipids.txt", sep = "\t", quote = FALSE, row.names = FALSE) #Take list of significant VIP. Select only the lipids and join with annotation information. Select only columns of interest and save as a txt file
```

#### Identify VIP in each module

I will only identify VIP in modules that were significantly correlated with a temperature condition, which will exclude ME13 and ME15.


```{r}
overallVIP_module0 <- significantVIP %>%
  filter(., lipid %in% module0_lipids$lipid) %>%
  mutate(module = "module0") #Identify overall VIP present in module
overallVIP_module0
```

```{r}
overallVIP_module1 <- significantVIP %>%
  filter(., lipid %in% module1_lipids$lipid) %>%
  mutate(module = "module1") #Identify overall VIP present in module
overallVIP_module1
```

```{r}
overallVIP_module2 <- significantVIP %>%
  filter(., lipid %in% module2_lipids$lipid) %>%
  mutate(module = "module2") #Identify overall VIP present in module
overallVIP_module2
```

```{r}
overallVIP_module3 <- significantVIP %>%
  filter(., lipid %in% module3_lipids$lipid) %>%
  mutate(module = "module3") #Identify overall VIP present in module
overallVIP_module3
```

```{r}
overallVIP_module4 <- significantVIP %>%
  filter(., lipid %in% module4_lipids$lipid) %>%
  mutate(module = "module4") #Identify overall VIP present in module
overallVIP_module4
```

```{r}
overallVIP_module5 <- significantVIP %>%
  filter(., lipid %in% module5_lipids$lipid) %>%
  mutate(module = "module5") #Identify overall VIP present in module
overallVIP_module5
```

```{r}
overallVIP_module6 <- significantVIP %>%
  filter(., lipid %in% module6_lipids$lipid) %>%
  mutate(module = "module6") #Identify overall VIP present in module
overallVIP_module6
```

```{r}
overallVIP_module7 <- significantVIP %>%
  filter(., lipid %in% module7_lipids$lipid) %>%
  mutate(module = "module7") #Identify overall VIP present in module
overallVIP_module7
```

```{r}
overallVIP_module8 <- significantVIP %>%
  filter(., lipid %in% module8_lipids$lipid) %>%
  mutate(module = "module8") #Identify overall VIP present in module
overallVIP_module8
```

```{r}
overallVIP_module9 <- significantVIP %>%
  filter(., lipid %in% module9_lipids$lipid) %>%
  mutate(module = "module9") #Identify overall VIP present in module
overallVIP_module9
```

```{r}
overallVIP_module10 <- significantVIP %>%
  filter(., lipid %in% module10_lipids$lipid) %>%
  mutate(module = "module10") #Identify overall VIP present in module
overallVIP_module10
```

```{r}
overallVIP_module11 <- significantVIP %>%
  filter(., lipid %in% module11_lipids$lipid) %>%
  mutate(module = "module11") #Identify overall VIP present in module
overallVIP_module11
```

```{r}
overallVIP_module12 <- significantVIP %>%
  filter(., lipid %in% module12_lipids$lipid) %>%
  mutate(module = "module12") #Identify overall VIP present in module
overallVIP_module12
```

```{r}
overallVIP_allModules <- rbind(overallVIP_module0,
                               overallVIP_module1,
                               overallVIP_module2,
                               overallVIP_module3,
                               overallVIP_module4,
                               overallVIP_module5,
                               overallVIP_module6,
                               overallVIP_module7,
                               overallVIP_module8,
                               overallVIP_module9,
                               overallVIP_module10,
                               overallVIP_module11,
                               overallVIP_module12)
overallVIP_allModules
```

```{r}
write.table(overallVIP_allModules, "metaboanalyst/all-module-overall-VIP.txt", sep = "\t", quote = FALSE, row.names = FALSE)
```

#### Identify VIP from significant pathways in each module

### Pairwise VIP

#### Identify pairwise VIP in each module

I'm only interested in finding the pairwise VIP associated with the treatment conditions that a specific module was associated with:

- Module 0: 5
- Module 1: 13, 30
- Module 2: 13, 30
- Module 3: 5, 30
- Module 4: 13, 30
- Module 5: 30
- Module 6: 30
- Module 7: 13, 30
- Module 8: 30
- Module 9: 5, 30
- Module 10: 13, 30
- Module 11: 5, 30
- Module 12: 13

```{r}
VIP_module0 <- rbind(t.test_13v5 %>%
                       mutate(., comparison = "13v5") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module0_lipids$lipid)) %>% 
  mutate(module = "module0") #Identify pairwise VIP present in module
VIP_module0
```

```{r}
VIP_module1 <- rbind(t.test_13v30 %>%
                       mutate(., comparison = "13v30") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module1_lipids$lipid)) %>% 
  mutate(module = "module1") #Identify pairwise VIP present in module
VIP_module1
```

```{r}
VIP_module2 <- rbind(t.test_13v5 %>%
                       mutate(., comparison = "13v30") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module2_lipids$lipid)) %>% 
  mutate(module = "module2") #Identify pairwise VIP present in module
VIP_module2
```

```{r}
VIP_module3 <- rbind(t.test_13v5 %>%
                       mutate(., comparison = "13v5") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module3_lipids$lipid),
                     t.test_13v30 %>%
                       mutate(., comparison = "13v30") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module3_lipids$lipid)) %>% 
  mutate(module = "module3") #Identify pairwise VIP present in module 3
VIP_module3
```

```{r}
VIP_module4 <- rbind(t.test_13v30 %>%
                       mutate(., comparison = "13v30") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module4_lipids$lipid)) %>% 
  mutate(module = "module4") #Identify pairwise VIP present in module
VIP_module4
```

```{r}
VIP_module5 <- rbind(t.test_13v30 %>%
                       mutate(., comparison = "13v30") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module5_lipids$lipid)) %>% 
  mutate(module = "module5") #Identify pairwise VIP present in module
VIP_module5
```

```{r}
VIP_module6 <- rbind(t.test_13v30 %>%
                       mutate(., comparison = "13v30") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module6_lipids$lipid)) %>% 
  mutate(module = "module6") #Identify pairwise VIP present in module
VIP_module6
```

```{r}
VIP_module7 <- rbind(t.test_13v30 %>%
                       mutate(., comparison = "13v30") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module7_lipids$lipid)) %>% 
  mutate(module = "module7") #Identify pairwise VIP present in module
VIP_module7
```

```{r}
VIP_module8 <- rbind(t.test_13v30 %>%
                       mutate(., comparison = "13v30") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module8_lipids$lipid)) %>% 
  mutate(module = "module8") #Identify pairwise VIP present in module
VIP_module8
```

```{r}
VIP_module9 <- rbind(t.test_13v30 %>%
                       mutate(., comparison = "13v30") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module9_lipids$lipid),
                     t.test_13v5 %>%
                       mutate(., comparison = "13v5") %>%
                       filter(., p.adj < 0.05) %>%
                       filter(., lipid %in% module9_lipids$lipid)) %>% 
  mutate(module = "module9") #Identify pairwise VIP present in module
VIP_module9
```
```{r}
VIP_module10 <- rbind(t.test_13v30 %>%
                        mutate(., comparison = "13v30") %>%
                        filter(., p.adj < 0.05) %>%
                        filter(., lipid %in% module10_lipids$lipid)) %>% 
  mutate(module = "module10") #Identify pairwise VIP present in module
VIP_module10
```

```{r}
VIP_module11 <- rbind(t.test_13v30 %>%
                        mutate(., comparison = "13v30") %>%
                        filter(., p.adj < 0.05) %>%
                        filter(., lipid %in% module11_lipids$lipid),
                      t.test_13v5 %>%
                        mutate(., comparison = "13v5") %>%
                        filter(., p.adj < 0.05) %>%
                        filter(., lipid %in% module11_lipids$lipid)) %>% 
  mutate(module = "module11") #Identify pairwise VIP present in module
VIP_module11
```

```{r}
VIP_module12 <- rbind(t.test_13v30 %>%
                        mutate(., comparison = "13v30") %>%
                        filter(., p.adj < 0.05) %>%
                        filter(., lipid %in% module12_lipids$lipid),
                      t.test_13v5 %>%
                        mutate(., comparison = "13v5") %>%
                        filter(., p.adj < 0.05) %>%
                        filter(., lipid %in% module12_lipids$lipid)) %>% 
  mutate(module = "module12") #Identify pairwise VIP present in module
VIP_module12
```

```{r}
pairwiseVIP_allModules <- rbind(VIP_module0,
                                VIP_module1,
                                VIP_module2,
                                VIP_module3,
                                VIP_module4,
                                VIP_module5,
                                VIP_module6,
                                VIP_module7,
                                VIP_module8,
                                VIP_module9,
                                VIP_module10,
                                VIP_module11,
                                VIP_module12) #Combine all VIP lists
head(pairwiseVIP_allModules)
```

```{r}
write.table(pairwiseVIP_allModules, "metaboanalyst/all-module-VIP.txt", sep = "\t", quote = FALSE, row.names = FALSE)
```


# CODE TO REORGANIZE

## Enrichment compound class analysis

### Analysis in MetaboAnalyst interface

The first kind of enrichment analysis I will complete is looking at compound structures. To do this, I will upload the list of metabolite names for each module (generated above) to the [MetaboAnalyst interface](https://www.metaboanalyst.ca/MetaboAnalyst/upload/EnrichUploadView.xhtml). Then, I will conduct an enrichment of *main class chemical structures*. 

> Enrichment tests are based on the well-established globaltest to test associations between metabolite sets and the outcome. The algorithm uses a generalized linear model to compute a ‘Q-stat’ for each metabolite set. The Q-stat is calculated as the average of the Q values calculated for the each single lipids; while the Q value is the squared covariance between the metabolite and the outcome. The globaltest has been shown to exhibit similar or superior performance when tested against several other popular methods.

> Metabolite sets: Unlike transcriptomics which allows comprehensive gene expression profiling, targeted lipidomics usually covers only a small percentage of metabolome (the actual coverage is platform/protocol specific). This means that lipids (defined in our current pathways or metabolite sets) do not have equal probabilities of being measured in your studies, and the enriched functions are the results from both platform/protocol specific effects and biological perturbations. Since the primary interest is to detect the latter, we highly recommend uploading a reference metabolome containing all measurable lipids from your platform to eliminate the former effects.

I don't have a reference metabolome and I didn't perform targeted lipidomics. I used metabolite sets containing at least two entries and all compounds in the selected library as a reference.

Certain compounds were not recognized by MetaboAnalyst, or require manual PubChem/KEGG ID correction. The resulting name maps (input names v.s names used for enrichment analysis) from MetaboAnalyst were renamed according to module number and saved [here](https://github.com/yaaminiv/green-crab-lipidomics/tree/main/output/06-lipidomics-analysis/metaboanalyst/name-maps).

The output tables (msea_ora_result.csv files from MetaboAnalyst) were renamed according to module number and saved [here](https://github.com/yaaminiv/green-crab-lipidomics/tree/main/output/06-lipidomics-analysis/metaboanalyst/msea-compoundClass/enrichment-output).

### View results

#### Import results

```{r}
#Import dataframes from each module. Add a Module column and rename the first column.

module0_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module0-msea_ora_result.csv") %>%
  mutate(., Module = "0") %>%
  dplyr::rename(., compoundClass = X)
module1_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module1-msea_ora_result.csv") %>%
  mutate(., Module = "1") %>%
  dplyr::rename(., compoundClass = X)
module2_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module2-msea_ora_result.csv") %>%
  mutate(., Module = "2") %>%
  dplyr::rename(., compoundClass = X)
module3_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module3-msea_ora_result.csv") %>%
  mutate(., Module = "3") %>%
  dplyr::rename(., compoundClass = X)
module4_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module4-msea_ora_result.csv") %>%
  mutate(., Module = "4") %>%
  dplyr::rename(., compoundClass = X)
module5_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module5-msea_ora_result.csv") %>%
  mutate(., Module = "5") %>%
  dplyr::rename(., compoundClass = X)
module6_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module6-msea_ora_result.csv") %>%
  mutate(., Module = "6") %>%
  dplyr::rename(., compoundClass = X)
module7_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module7-msea_ora_result.csv") %>%
  mutate(., Module = "7") %>%
  dplyr::rename(., compoundClass = X)
module8_class <- read.csv("metaboanalyst/msea-compoundClass/enrichment-output/module8-msea_ora_result.csv") %>%
  mutate(., Module = "8") %>%
  dplyr::rename(., compoundClass = X)
```

```{r}
compound_classes <- rbind(module0_class,
                          module1_class,
                          module2_class,
                          module3_class,
                          module4_class,
                          module5_class,
                          module6_class,
                          module7_class,
                          module8_class) #Create dataframe with compound classes
head(compound_classes) #Confirm dataframe creation
```

```{r}
write.csv(compound_classes, "metaboanalyst/msea-compoundClass/all-module-compound-classes.csv", quote = FALSE, row.names = FALSE) #Save dataframe with all compound classes for all modules
```

#### Format results

```{r}
sig_classes_comp <- compound_classes %>%
  filter(., FDR < 0.05) %>%
  dplyr::select(., compoundClass, total, hits, FDR, Module) #Filter out only significant compound classes using a FDR < 0.05 threshold. Keep compoundClass, total, hits, FDR, and Module columns.
head(sig_classes_comp) 
```

```{r}
write.csv(sig_classes_comp, "metaboanalyst/msea-compoundClass/significant-compound-classes.csv", quote = FALSE, row.names = FALSE)
```

#### Plot results

```{r}
ggplot(sig_classes_comp, aes(x = Module, y = compoundClass)) + 
  geom_point(aes(size = hits)) +
  scale_size(name = "Metabolites",
             range = c(4,15), 
             limits = c(1,15)) +
  xlab("Module Eigengene") + ylab("Compound Class") +
  theme_classic(base_size = 15) #Plot significantly enriched compound classes for each module. Scale point size by the number of metabolite hits in each category. Define x- and y- axis labels. Change the angle of the x-axis text.
ggsave("metaboanalyst/figures/compound-class-dotplot.pdf", height = 8.5, width = 11)
```

## KEGG Pathway Analysis

### Analysis in MetaboAnalyst Interface

I'll return to the [MetaboAnalyst enrichment interface](https://www.metaboanalyst.ca/MetaboAnalyst/upload/EnrichUploadView.xhtml) and use the same steps to conduct a KEGG Pathway enrichment. Again, I will upload metabolite names and correct them as needed within the interface. KEGG Pathway enrichment results are saved [here](https://github.com/yaaminiv/green-crab-lipidomics/tree/main/output/05-lipidomics-analysis/metaboanalyst/msea-KEGG/enrichment-output).

### View results

#### Import results

```{r}
#Import dataframes from each module. Add a Module column and rename the first column.

module0_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module0-msea_ora_result.csv") %>%
  mutate(., Module = "0") %>%
  dplyr::rename(., KEGG = X)
module1_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module1-msea_ora_result.csv") %>%
  mutate(., Module = "1") %>%
  dplyr::rename(., KEGG = X)
module2_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module2-msea_ora_result.csv") %>%
  mutate(., Module = "2") %>%
  dplyr::rename(., KEGG = X)
module3_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module3-msea_ora_result.csv") %>%
  mutate(., Module = "3") %>%
  dplyr::rename(., KEGG = X)
module4_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module4-msea_ora_result.csv") %>%
  mutate(., Module = "4") %>%
  dplyr::rename(., KEGG = X)
module5_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module5-msea_ora_result.csv") %>%
  mutate(., Module = "5") %>%
  dplyr::rename(., KEGG = X)
# module6_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module6-msea_ora_result.csv") %>%
#   mutate(., Module = "6") %>%
#   dplyr::rename(., KEGG = X)
module7_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module7-msea_ora_result.csv") %>%
  mutate(., Module = "7") %>%
  dplyr::rename(., KEGG = X)
# module8_KEGG <- read.csv("metaboanalyst/msea-KEGG/enrichment-output/module8-msea_ora_result.csv") %>%
#   mutate(., Module = "8") %>%
#   dplyr::rename(., KEGG = X)
```

```{r}
KEGG_pathways <- rbind(module0_KEGG,
                       module1_KEGG,
                       module2_KEGG,
                       module3_KEGG,
                       module4_KEGG,
                       module5_KEGG,
                       # module6_KEGG,
                       module7_KEGG
                       # module8_KEGG
) #Create dataframe with compound classes
head(KEGG_pathways) #Confirm dataframe creation
```

```{r}
write.csv(KEGG_pathways, "metaboanalyst/msea-KEGG/all-module-KEGG-pathways.csv", quote = FALSE, row.names = FALSE) #Save dataframe with all compound classes for all modules
```

#### Format results

```{r}
sig_KEGG_pathways <- KEGG_pathways %>%
  filter(., FDR < 0.05) %>%
  dplyr::select(., KEGG, total, hits, FDR, Module) #Filter out only significant compound classes using a FDR < 0.05 threshold. Keep KEGG, total, hits, FDR, and Module columns.
head(sig_KEGG_pathways) 
```

```{r}
write.csv(sig_KEGG_pathways, "metaboanalyst/msea-KEGG/significant-compound-classes.csv", quote = FALSE, row.names = FALSE)
```

#### Plot results

```{r}
ggplot(sig_KEGG_pathways, aes(x = Module, y = KEGG)) + 
  geom_point(aes(size = hits)) +
  scale_size(name = "Metabolites",
             range = c(4,15), 
             limits = c(1,15)) +
  xlab("Module Eigengene") + ylab("KEGG Pathway") +
  theme_classic(base_size = 15) #Plot significantly enriched KEGG pathways for each module. Scale point size by the number of metabolite hits in each category. Define x- and y- axis labels. Change the angle of the x-axis text.
ggsave("metaboanalyst/figures/KEGG-pathway-dotplot.pdf", height = 8.5, width = 11)
```

**TO DO**:

- figure out why modules 6 and 8 aren't running through KEGG enrichment


